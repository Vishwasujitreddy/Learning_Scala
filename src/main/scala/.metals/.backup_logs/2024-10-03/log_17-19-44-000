2024.10.02 11:11:47 INFO  Started: Metals version 1.3.5 in folders 'D:\Practise\hello-world\src\main\scala' for client Visual Studio Code 1.93.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@afcf4c3]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@39c57e7a]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@afcf4c3]
2024.10.02 11:11:47 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.02 11:11:48 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_Scala.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:50 INFO  Running List(C:\Users\Vishwasujit\AppData\Local\Coursier\data\bin\scala-cli.BAT, setup-ide, D:\Practise\hello-world\src\main\scala)
2024.10.02 11:11:50 INFO  Attempting to connect to the build server...
2024.10.02 11:11:50 INFO  Running BSP server List(C:\Users\Vishwasujit\AppData\Local\Coursier\data\bin\.scala-cli.aux.exe, bsp, --json-options, D:\Practise\hello-world\src\main\scala\.scala-build\ide-options-v2.json, --json-launcher-options, D:\Practise\hello-world\src\main\scala\.scala-build\ide-launcher-options.json, --envs-file, D:\Practise\hello-world\src\main\scala\.scala-build\ide-envs.json, D:\Practise\hello-world\src\main\scala)
2024.10.02 11:11:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practise\hello-world\src\main\scala\.metals\bsp.trace.json or C:\Users\Vishwasujit\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-frontend_2.12/1.5.17-sc-2/bloop-frontend_2.12-1.5.17-sc-2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-frontend_2.12/1.5.17-sc-2/bloop-frontend_2.12-1.5.17-sc-2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/libdaemon/libdaemon_2.12/0.0.11/libdaemon_2.12-0.0.11.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-backend_2.12/1.5.17-sc-2/bloop-backend_2.12-1.5.17-sc-2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/epfl/scala/scala-debug-adapter_2.12/4.1.1/scala-debug-adapter_2.12-4.1.1.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.4.14/logback-classic-1.4.14.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/epfl/scala/bloop-config_2.12/2.0.0/bloop-config_2.12-2.0.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/libdaemon/libdaemon_2.12/0.0.11/libdaemon_2.12-0.0.11.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-backend_2.12/1.5.17-sc-2/bloop-backend_2.12-1.5.17-sc-2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.4.14/logback-classic-1.4.14.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/epfl/scala/scala-debug-adapter_2.12/4.1.1/scala-debug-adapter_2.12-4.1.1.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/epfl/scala/bloop-config_2.12/2.0.0/bloop-config_2.12-2.0.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/qos/logback/logback-parent/1.4.14/logback-parent-1.4.14.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/qos/logback/logback-parent/1.4.14/logback-parent-1.4.14.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-ivy_2.12/1.10.0/librarymanagement-ivy_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/qos/logback/logback-core/1.4.14/logback-core-1.4.14.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/epfl/scala/com-microsoft-java-debug-core/0.34.0+30/com-microsoft-java-debug-core-0.34.0+30.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/test-agent/1.10.0/test-agent-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/lihaoyi/sourcecode_2.12/0.4.1/sourcecode_2.12-0.4.1.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scalameta/parsers_2.12/4.9.5/parsers_2.12-4.9.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/qos/logback/logback-core/1.4.14/logback-core-1.4.14.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/nailgun-server/1.0.7/nailgun-server-1.0.7.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/epfl/scala/com-microsoft-java-debug-core/0.34.0+30/com-microsoft-java-debug-core-0.34.0+30.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-shared_2.12/1.5.17-sc-2/bloop-shared_2.12-1.5.17-sc-2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/test-agent/1.10.0/test-agent-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-ivy_2.12/1.10.0/librarymanagement-ivy_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/nailgun-server/1.0.7/nailgun-server-1.0.7.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/lihaoyi/sourcecode_2.12/0.4.1/sourcecode_2.12-0.4.1.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-shared_2.12/1.5.17-sc-2/bloop-shared_2.12-1.5.17-sc-2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scalameta/parsers_2.12/4.9.5/parsers_2.12-4.9.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc_2.12/1.10.0/zinc_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/jsonrpc4s_2.12/0.1.1/jsonrpc4s_2.12-0.1.1.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/get-coursier/interface/1.0.13/interface-1.0.13.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/net/java/dev/jna/jna-platform/4.4.0/jna-platform-4.4.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-core_2.12/1.10.0/librarymanagement-core_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scalameta/trees_2.12/4.9.5/trees_2.12-4.9.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/net/java/dev/jna/jna-platform/4.4.0/jna-platform-4.4.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/get-coursier/interface/1.0.13/interface-1.0.13.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/net/java/dev/jna/jna/4.5.2/jna-4.5.2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc_2.12/1.10.0/zinc_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-core_2.12/1.10.0/librarymanagement-core_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/jsonrpc4s_2.12/0.1.1/jsonrpc4s_2.12-0.1.1.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/net/java/dev/jna/jna/4.5.2/jna-4.5.2.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scalameta/trees_2.12/4.9.5/trees_2.12-4.9.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-compile-core_2.12/1.10.0/zinc-compile-core_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scalameta/common_2.12/4.9.5/common_2.12-4.9.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/launcher-interface/1.0.0/launcher-interface-1.0.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-classfile_2.12/1.10.0/zinc-classfile_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist_2.12/1.10.0/zinc-persist_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/github/plokhotnyuk/jsoniter-scala/jsoniter-scala-core_2.12/2.13.5/jsoniter-scala-core_2.12-2.13.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-compile-core_2.12/1.10.0/zinc-compile-core_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scalameta/common_2.12/4.9.5/common_2.12-4.9.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-core_2.12/1.10.0/zinc-core_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist_2.12/1.10.0/zinc-persist_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/launcher-interface/1.0.0/launcher-interface-1.0.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-classfile_2.12/1.10.0/zinc-classfile_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-core_2.12/1.10.0/zinc-core_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/github/plokhotnyuk/jsoniter-scala/jsoniter-scala-core_2.12/2.13.5/jsoniter-scala-core_2.12-2.13.5.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/thesamet/scalapb/scalapb-runtime_2.12/0.11.15/scalapb-runtime_2.12-0.11.15.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-apiinfo_2.12/1.10.0/zinc-apiinfo_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-classpath_2.12/1.10.0/zinc-classpath_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist-core-assembly/1.10.0/zinc-persist-core-assembly-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/compiler-interface/1.10.0/compiler-interface-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/thesamet/scalapb/scalapb-runtime_2.12/0.11.15/scalapb-runtime_2.12-0.11.15.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-apiinfo_2.12/1.10.0/zinc-apiinfo_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-classpath_2.12/1.10.0/zinc-classpath_2.12-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist-core-assembly/1.10.0/zinc-persist-core-assembly-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/compiler-interface/1.10.0/compiler-interface-1.10.0.pom
2024.10.02 11:11:50 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/compiler-bridge_2.12/1.10.0/compiler-bridge_2.12-1.10.0.pom
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/thesamet/scalapb/lenses_2.12/0.11.15/lenses_2.12-0.11.15.pom
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/compiler-bridge_2.12/1.10.0/compiler-bridge_2.12-1.10.0.pom
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/thesamet/scalapb/lenses_2.12/0.11.15/lenses_2.12-0.11.15.pom
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/lihaoyi/sourcecode_2.12/0.4.1/sourcecode_2.12-0.4.1.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/compiler-interface/1.10.0/compiler-interface-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/epfl/scala/bloop-config_2.12/2.0.0/bloop-config_2.12-2.0.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/epfl/scala/scala-debug-adapter_2.12/4.1.1/scala-debug-adapter_2.12-4.1.1.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-backend_2.12/1.5.17-sc-2/bloop-backend_2.12-1.5.17-sc-2.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc_2.12/1.10.0/zinc_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/lihaoyi/sourcecode_2.12/0.4.1/sourcecode_2.12-0.4.1.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-frontend_2.12/1.5.17-sc-2/bloop-frontend_2.12-1.5.17-sc-2.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/compiler-interface/1.10.0/compiler-interface-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/epfl/scala/com-microsoft-java-debug-core/0.34.0+30/com-microsoft-java-debug-core-0.34.0+30.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/epfl/scala/bloop-config_2.12/2.0.0/bloop-config_2.12-2.0.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/thesamet/scalapb/lenses_2.12/0.11.15/lenses_2.12-0.11.15.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/thesamet/scalapb/lenses_2.12/0.11.15/lenses_2.12-0.11.15.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scalameta/parsers_2.12/4.9.5/parsers_2.12-4.9.5.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/epfl/scala/com-microsoft-java-debug-core/0.34.0+30/com-microsoft-java-debug-core-0.34.0+30.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/jsonrpc4s_2.12/0.1.1/jsonrpc4s_2.12-0.1.1.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc_2.12/1.10.0/zinc_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-apiinfo_2.12/1.10.0/zinc-apiinfo_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-apiinfo_2.12/1.10.0/zinc-apiinfo_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/compiler-bridge_2.12/1.10.0/compiler-bridge_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/epfl/scala/scala-debug-adapter_2.12/4.1.1/scala-debug-adapter_2.12-4.1.1.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/thesamet/scalapb/scalapb-runtime_2.12/0.11.15/scalapb-runtime_2.12-0.11.15.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-backend_2.12/1.5.17-sc-2/bloop-backend_2.12-1.5.17-sc-2.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-core_2.12/1.10.0/zinc-core_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/jsonrpc4s_2.12/0.1.1/jsonrpc4s_2.12-0.1.1.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-core_2.12/1.10.0/librarymanagement-core_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-frontend_2.12/1.5.17-sc-2/bloop-frontend_2.12-1.5.17-sc-2.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-classfile_2.12/1.10.0/zinc-classfile_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/compiler-bridge_2.12/1.10.0/compiler-bridge_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-ivy_2.12/1.10.0/librarymanagement-ivy_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scalameta/parsers_2.12/4.9.5/parsers_2.12-4.9.5.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-classpath_2.12/1.10.0/zinc-classpath_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-classfile_2.12/1.10.0/zinc-classfile_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist-core-assembly/1.10.0/zinc-persist-core-assembly-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-classpath_2.12/1.10.0/zinc-classpath_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/qos/logback/logback-core/1.4.14/logback-core-1.4.14.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-core_2.12/1.10.0/zinc-core_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-shared_2.12/1.5.17-sc-2/bloop-shared_2.12-1.5.17-sc-2.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/bloop-shared_2.12/1.5.17-sc-2/bloop-shared_2.12-1.5.17-sc-2.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scalameta/trees_2.12/4.9.5/trees_2.12-4.9.5.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-core_2.12/1.10.0/librarymanagement-core_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/test-agent/1.10.0/test-agent-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/librarymanagement-ivy_2.12/1.10.0/librarymanagement-ivy_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scalameta/common_2.12/4.9.5/common_2.12-4.9.5.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/test-agent/1.10.0/test-agent-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/libdaemon/libdaemon_2.12/0.0.11/libdaemon_2.12-0.0.11.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/libdaemon/libdaemon_2.12/0.0.11/libdaemon_2.12-0.0.11.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/get-coursier/interface/1.0.13/interface-1.0.13.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/qos/logback/logback-core/1.4.14/logback-core-1.4.14.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist_2.12/1.10.0/zinc-persist_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist_2.12/1.10.0/zinc-persist_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.4.14/logback-classic-1.4.14.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/thesamet/scalapb/scalapb-runtime_2.12/0.11.15/scalapb-runtime_2.12-0.11.15.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/org/scala-sbt/zinc-compile-core_2.12/1.10.0/zinc-compile-core_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-persist-core-assembly/1.10.0/zinc-persist-core-assembly-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/com/github/plokhotnyuk/jsoniter-scala/jsoniter-scala-core_2.12/2.13.5/jsoniter-scala-core_2.12-2.13.5.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/com/github/plokhotnyuk/jsoniter-scala/jsoniter-scala-core_2.12/2.13.5/jsoniter-scala-core_2.12-2.13.5.jar
2024.10.02 11:11:51 INFO  BSP server: Downloading https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/nailgun-server/1.0.7/nailgun-server-1.0.7.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scala-sbt/zinc-compile-core_2.12/1.10.0/zinc-compile-core_2.12-1.10.0.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.4.14/logback-classic-1.4.14.jar
2024.10.02 11:11:51 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/github/alexarchambault/bleep/nailgun-server/1.0.7/nailgun-server-1.0.7.jar
2024.10.02 11:11:52 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scalameta/common_2.12/4.9.5/common_2.12-4.9.5.jar
2024.10.02 11:11:52 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/org/scalameta/trees_2.12/4.9.5/trees_2.12-4.9.5.jar
2024.10.02 11:11:52 INFO  BSP server: Downloaded https://repo1.maven.org/maven2/io/get-coursier/interface/1.0.13/interface-1.0.13.jar
2024.10.02 11:11:52 INFO  BSP server: Starting compilation server
2024.10.02 11:11:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_seven segment clock.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:58 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_seven segment clock.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:58 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_Terminal.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:58 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_Terminal.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:59 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalDigit.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:59 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalDigit.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:59 INFO  time: Connected to build server in 9.11s
2024.10.02 11:11:59 INFO  Connected to Build server: scala-cli v1.4.3
2024.10.02 11:11:59 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalString.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:11:59 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalString.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:00 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:11:59 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:00 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:00 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:01 WARN  no build target for: D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala
Oct 02, 2024 11:12:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 51
2024.10.02 11:12:01 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:01 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:01 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:01 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:01 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_twoDimensionalTime.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:01 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_seven segment clock.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:02 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Clock\Clock_seven segment clock.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:12:03 INFO  time: Imported build in 3.72s
2024.10.02 11:12:02 INFO  running doctor check
2024.10.02 11:12:02 INFO  java targets: scala_f4dd477a3a-test, scala_f4dd477a3a
2024.10.02 11:12:03 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:12:03 INFO  time: compiled scala_f4dd477a3a in 0.59s
2024.10.02 11:12:09 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.02 11:12:10 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:12:10 INFO  time: indexed workspace in 7.47s
2024.10.02 11:12:10 INFO  Deduplicating compilation of scala_f4dd477a3a from bsp client 'scala-cli 1.4.3' (since 11.938s)
2024.10.02 11:12:10 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:12:11 INFO  time: compiled scala_f4dd477a3a in 0.66s
2024.10.02 11:12:11 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:12:11 INFO  time: compiled scala_f4dd477a3a in 0.47s
2024.10.02 11:12:11 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:12:12 INFO  time: compiled scala_f4dd477a3a in 0.3s
2024.10.02 11:12:46 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:12:46 INFO  time: compiled scala_f4dd477a3a in 0.3s
2024.10.02 11:13:09 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:13:09 INFO  time: compiled scala_f4dd477a3a in 0.26s
Oct 02, 2024 11:13:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/time/LocalDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.HOURS_PER_DAY;\nimport static java.time.LocalTime.MICROS_PER_DAY;\nimport static java.time.LocalTime.MILLIS_PER_DAY;\nimport static java.time.LocalTime.MINUTES_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_HOUR;\nimport static java.time.LocalTime.NANOS_PER_MINUTE;\nimport static java.time.LocalTime.NANOS_PER_SECOND;\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * \u003cp\u003e\n * {@code LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be\n * stored in a {@code LocalDateTime}.\n * \u003cp\u003e\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\n@jdk.internal.ValueBased\npublic final class LocalDateTime\n        implements Temporal, TemporalAdjuster, ChronoLocalDateTime\u003cLocalDate\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDateTime}, \u0027-999999999-01-01T00:00:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final LocalDateTime MIN \u003d LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    /**\n     * The maximum supported {@code LocalDateTime}, \u0027+999999999-12-31T23:59:59.999999999\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final LocalDateTime MAX \u003d LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    /**\n     * Serialization version.\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 6207766400415563566L;\n\n    /**\n     * The date part.\n     */\n    private final LocalDate date;\n    /**\n     * The time part.\n     */\n    private final LocalTime time;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock and default time-zone, not null\n     */\n    public static LocalDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static LocalDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static LocalDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        ZoneOffset offset \u003d clock.getZone().getRules().getOffset(now);\n        return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a date and time.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @return the local date-time, not null\n     */\n    public static LocalDateTime of(LocalDate date, LocalTime time) {\n        Objects.requireNonNull(date, \"date\");\n        Objects.requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range,\n     *  or if the nano-of-second is invalid\n     */\n    public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {\n        Objects.requireNonNull(offset, \"offset\");\n        NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        long localSecond \u003d epochSecond + offset.getTotalSeconds();  // overflow caught later\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        int secsOfDay \u003d Math.floorMod(localSecond, SECONDS_PER_DAY);\n        LocalDate date \u003d LocalDate.ofEpochDay(localEpochDay);\n        LocalTime time \u003d LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion extracts and combines the {@code LocalDate} and the\n     * {@code LocalTime} from the temporal object.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDateTime}\n     */\n    public static LocalDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof LocalDateTime) {\n            return (LocalDateTime) temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return ((ZonedDateTime) temporal).toLocalDateTime();\n        } else if (temporal instanceof OffsetDateTime) {\n            return ((OffsetDateTime) temporal).toLocalDateTime();\n        }\n        try {\n            LocalDate date \u003d LocalDate.from(temporal);\n            LocalTime time \u003d LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30\", not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param date  the date part of the date-time, validated not null\n     * @param time  the time part of the date-time, validated not null\n     */\n    private LocalDateTime(LocalDate date, LocalTime time) {\n        this.date \u003d date;\n        this.time \u003d time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param newDate  the date of the new date-time, not null\n     * @param newTime  the time of the new date-time, not null\n     * @return the date-time, not null\n     */\n    private LocalDateTime with(LocalDate newDate, LocalTime newTime) {\n        if (date \u003d\u003d newDate \u0026\u0026 time \u003d\u003d newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        if (field instanceof ChronoField chronoField) {\n            return chronoField.isDateBased() || chronoField.isTimeBased();\n        }\n        return field !\u003d null \u0026\u0026 field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDateTime.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField chronoField) {\n            return (chronoField.isTimeBased() ? time.range(field) : date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in\n     * an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField chronoField) {\n            return (chronoField.isTimeBased() ? time.get(field) : date.get(field));\n        }\n        return ChronoLocalDateTime.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField chronoField) {\n            return (chronoField.isTimeBased() ? time.getLong(field) : date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    @Override\n    public LocalDate toLocalDate() {\n        return date;\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return date.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return date.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return date.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return date.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return date.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return date.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    @Override\n    public LocalTime toLocalTime() {\n        return time;\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return time.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return time.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return time.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return time.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d localDateTime.with(date);\n     *  result \u003d localDateTime.with(time);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return with((LocalDate) adjuster, time);\n        } else if (adjuster instanceof LocalTime) {\n            return with(date, (LocalTime) adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return (LocalDateTime) adjuster;\n        }\n        return (LocalDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField chronoField) {\n            if (chronoField.isTimeBased()) {\n                return with(date, time.with(field, newValue));\n            } else {\n                return with(date.with(field, newValue), time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return with(date.withYear(year), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDateTime withMonth(int month) {\n        return with(date.withMonth(month), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return with(date.withDayOfMonth(dayOfMonth), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return with(date.withDayOfYear(dayOfYear), time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return a {@code LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public LocalDateTime withHour(int hour) {\n        LocalTime newTime \u003d time.withHour(hour);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public LocalDateTime withMinute(int minute) {\n        LocalTime newTime \u003d time.withMinute(minute);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public LocalDateTime withSecond(int second) {\n        LocalTime newTime \u003d time.withSecond(second);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return a {@code LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public LocalDateTime withNano(int nanoOfSecond) {\n        LocalTime newTime \u003d time.withNano(nanoOfSecond);\n        return with(date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return a {@code LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public LocalDateTime truncatedTo(TemporalUnit unit) {\n        return with(date, time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period periodToAdd) {\n            return with(date.plus(periodToAdd), time);\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.\n     * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with\n     * any overflow in days added equivalent to using {@link #plusDays(long)}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit chronoUnit) {\n            switch (chronoUnit) {\n                case NANOS: return plusNanos(amountToAdd);\n                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n                case SECONDS: return plusSeconds(amountToAdd);\n                case MINUTES: return plusMinutes(amountToAdd);\n                case HOURS: return plusHours(amountToAdd);\n                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return with(date.plus(amountToAdd, unit), time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusYears(long years) {\n        LocalDate newDate \u003d date.plusYears(years);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMonths(long months) {\n        LocalDate newDate \u003d date.plusMonths(months);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusWeeks(long weeks) {\n        LocalDate newDate \u003d date.plusWeeks(weeks);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusDays(long days) {\n        LocalDate newDate \u003d date.plusDays(days);\n        return with(newDate, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period periodToSubtract) {\n            return with(date.minus(periodToSubtract), time);\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, -1);\n   }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified period added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param newDate  the new date to base the calculation on, not null\n     * @param hours  the hours to add, may be negative\n     * @param minutes the minutes to add, may be negative\n     * @param seconds the seconds to add, may be negative\n     * @param nanos the nanos to add, may be negative\n     * @param sign  the sign to determine add or subtract\n     * @return the combined result, not null\n     */\n    private LocalDateTime plusWithOverflow(LocalDate newDate, long hours, long minutes, long seconds, long nanos, int sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) \u003d\u003d 0) {\n            return with(newDate, time);\n        }\n        long totDays \u003d nanos / NANOS_PER_DAY +             //   max/24*60*60*1B\n                seconds / SECONDS_PER_DAY +                //   max/24*60*60\n                minutes / MINUTES_PER_DAY +                //   max/24*60\n                hours / HOURS_PER_DAY;                     //   max/24\n        totDays *\u003d sign;                                   // total max*0.4237...\n        long totNanos \u003d nanos % NANOS_PER_DAY +                    //   max  86400000000000\n                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000\n                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000\n                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000\n        long curNoD \u003d time.toNanoOfDay();                       //   max  86400000000000\n        totNanos \u003d totNanos * sign + curNoD;                    // total 432000000000000\n        totDays +\u003d Math.floorDiv(totNanos, NANOS_PER_DAY);\n        long newNoD \u003d Math.floorMod(totNanos, NANOS_PER_DAY);\n        LocalTime newTime \u003d (newNoD \u003d\u003d curNoD ? time : LocalTime.ofNanoOfDay(newNoD));\n        return with(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override  // override for Javadoc\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) date;\n        }\n        return ChronoLocalDateTime.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDateTime.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDateTime} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDateTime end \u003d LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit chronoUnit) {\n            if (unit.isTimeBased()) {\n                long amount \u003d date.daysUntil(end.date);\n                if (amount \u003d\u003d 0) {\n                    return time.until(end.time, unit);\n                }\n                long timePart \u003d end.time.toNanoOfDay() - time.toNanoOfDay();\n                if (amount \u003e 0) {\n                    amount--;  // safe\n                    timePart +\u003d NANOS_PER_DAY;  // safe\n                } else {\n                    amount++;  // safe\n                    timePart -\u003d NANOS_PER_DAY;  // safe\n                }\n                switch (chronoUnit) {\n                    case NANOS:\n                        amount \u003d Math.multiplyExact(amount, NANOS_PER_DAY);\n                        break;\n                    case MICROS:\n                        amount \u003d Math.multiplyExact(amount, MICROS_PER_DAY);\n                        timePart \u003d timePart / 1000;\n                        break;\n                    case MILLIS:\n                        amount \u003d Math.multiplyExact(amount, MILLIS_PER_DAY);\n                        timePart \u003d timePart / 1_000_000;\n                        break;\n                    case SECONDS:\n                        amount \u003d Math.multiplyExact(amount, SECONDS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_SECOND;\n                        break;\n                    case MINUTES:\n                        amount \u003d Math.multiplyExact(amount, MINUTES_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_MINUTE;\n                        break;\n                    case HOURS:\n                        amount \u003d Math.multiplyExact(amount, HOURS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_HOUR;\n                        break;\n                    case HALF_DAYS:\n                        amount \u003d Math.multiplyExact(amount, 2);\n                        timePart \u003d timePart / (NANOS_PER_HOUR * 12);\n                        break;\n                }\n                return Math.addExact(amount, timePart);\n            }\n            LocalDate endDate \u003d end.date;\n            if (endDate.isAfter(date) \u0026\u0026 end.time.isBefore(time)) {\n                endDate \u003d endDate.minusDays(1);\n            } else if (endDate.isBefore(date) \u0026\u0026 end.time.isAfter(time)) {\n                endDate \u003d endDate.plusDays(1);\n            }\n            return date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param offset  the offset to combine with, not null\n     * @return the offset date-time formed from this date-time and the specified offset, not null\n     */\n    public OffsetDateTime atOffset(ZoneOffset offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * \u003cp\u003e\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *\u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    @Override\n    public ZonedDateTime atZone(ZoneId zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the date-times being compared are instances of {@code LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other);\n        }\n        return ChronoLocalDateTime.super.compareTo(other);\n    }\n\n    private int compareTo0(LocalDateTime other) {\n        int cmp \u003d date.compareTo0(other.toLocalDate());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is after the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003e 0;\n        }\n        return ChronoLocalDateTime.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is before the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003c 0;\n        }\n        return ChronoLocalDateTime.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is equal to the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDateTime.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * Compares this {@code LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@code LocalDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        return (obj instanceof LocalDateTime other)\n                \u0026\u0026 date.equals(other.date)\n                \u0026\u0026 time.equals(other.time);\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return date.hashCode() ^ time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSS}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return date.toString() + \u0027T\u0027 + time.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"{@docRoot}/serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(5);  // identifies a LocalDateTime\n     *  // the \u003ca href\u003d\"{@docRoot}/serialized-form.html#java.time.LocalDate\"\u003edate\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"{@docRoot}/serialized-form.html#java.time.LocalTime\"\u003etime\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    @java.io.Serial\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    @java.io.Serial\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        date.writeExternal(out);\n        time.writeExternal(out);\n    }\n\n    static LocalDateTime readExternal(DataInput in) throws IOException {\n        LocalDate date \u003d LocalDate.readExternal(in);\n        LocalTime time \u003d LocalTime.readExternal(in);\n        return LocalDateTime.of(date, time);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 11:13:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/time/LocalDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 11:15:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 281
2024.10.02 11:15:49 INFO  compiling scala_f4dd477a3a (26 scala sources)
Oct 02, 2024 11:15:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 287
2024.10.02 11:15:49 INFO  time: compiled scala_f4dd477a3a in 0.27s
Oct 02, 2024 11:16:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * Object Serialization Specification, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char value[]) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char value[], int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, offset, length, lookupCharset(charsetName));\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    @SuppressWarnings(\"removal\")\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        Objects.requireNonNull(charset);\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                int sl \u003d offset + length;\n                int dp \u003d 0;\n                byte[] dst \u003d null;\n                if (COMPACT_STRINGS) {\n                    dst \u003d new byte[length];\n                    while (offset \u003c sl) {\n                        int b1 \u003d bytes[offset];\n                        if (b1 \u003e\u003d 0) {\n                            dst[dp++] \u003d (byte)b1;\n                            offset++;\n                            continue;\n                        }\n                        if ((b1 \u003d\u003d (byte)0xc2 || b1 \u003d\u003d (byte)0xc3) \u0026\u0026\n                                offset + 1 \u003c sl) {\n                            int b2 \u003d bytes[offset + 1];\n                            if (!isNotContinuation(b2)) {\n                                dst[dp++] \u003d (byte)decode2(b1, b2);\n                                offset +\u003d 2;\n                                continue;\n                            }\n                        }\n                        // anything not a latin1, including the repl\n                        // we have to go with the utf16\n                        break;\n                    }\n                    if (offset \u003d\u003d sl) {\n                        if (dp !\u003d dst.length) {\n                            dst \u003d Arrays.copyOf(dst, dp);\n                        }\n                        this.value \u003d dst;\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                if (dp \u003d\u003d 0 || dst \u003d\u003d null) {\n                    dst \u003d new byte[length \u003c\u003c 1];\n                } else {\n                    byte[] buf \u003d new byte[length \u003c\u003c 1];\n                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n                    dst \u003d buf;\n                }\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n        } else {\n            int sl \u003d offset + length;\n            int dp \u003d 0;\n            byte[] dst \u003d null;\n            if (COMPACT_STRINGS) {\n                dst \u003d new byte[length];\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte) b1;\n                        offset++;\n                        continue;\n                    }\n                    if ((b1 \u003d\u003d (byte) 0xc2 || b1 \u003d\u003d (byte) 0xc3) \u0026\u0026\n                            offset + 1 \u003c sl) {\n                        int b2 \u003d bytes[offset + 1];\n                        if (!isNotContinuation(b2)) {\n                            dst[dp++] \u003d (byte) decode2(b1, b2);\n                            offset +\u003d 2;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    return new String(dst, LATIN1);\n                }\n            }\n            if (dp \u003d\u003d 0 || dst \u003d\u003d null) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n            if (dp !\u003d length) {\n                dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n            }\n            return new String(dst, UTF16);\n        }\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        if (ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return Arrays.copyOf(val, val.length);\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n            if (doReplace) {\n                ce.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            byte[] dst \u003d Arrays.copyOf(val, val.length);\n            for (int i \u003d 0; i \u003c dst.length; i++) {\n                if (dst[i] \u003c 0) {\n                    dst[i] \u003d \u0027?\u0027;\n                }\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return Arrays.copyOf(val, val.length);\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        if (!StringCoding.hasNegatives(sa, sp, len)) {\n            StringLatin1.inflate(sa, sp, da, dp, len);\n            return len;\n        } else {\n            int start \u003d sp;\n            int end \u003d sp + len;\n            while (sp \u003c end \u0026\u0026 sa[sp] \u003e\u003d 0) {\n                da[dp++] \u003d (char) sa[sp++];\n            }\n            return sp - start;\n        }\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        try {\n            CoderResult cr \u003d cd.decode(bb, cb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d cd.flush(cb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            // Substitution is always enabled,\n            // so this shouldn\u0027t happen\n            throw new Error(x);\n        }\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16)\n            return encodeUTF8_UTF16(val, doReplace);\n\n        if (!StringCoding.hasNegatives(val, 0, val.length))\n            return Arrays.copyOf(val, val.length);\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length)\n            return dst;\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        char c;\n        while (sp \u003c sl \u0026\u0026 (c \u003d StringUTF16.getChar(val, sp)) \u003c \u0027\\u0080\u0027) {\n            // ascii fast loop;\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, 0, bytes.length, charsetName);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte bytes[], Charset charset) {\n        this(bytes, 0, bytes.length, charset);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the platform\u0027s default charset.  The length of the new\n     * {@code String} is a function of the charset, and hence may not be equal\n     * to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(bytes, offset, length, Charset.defaultCharset());\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the platform\u0027s default charset.  The length of the new {@code\n     * String} is a function of the charset, and hence may not be equal to the\n     * length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        if (i \u003c 0 || i \u003e\u003d length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex ||\n            endIndex \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index \u003c 0 || index \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the platform\u0027s default charset.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName \u003d\u003d null) throw new NullPointerException();\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * platform\u0027s default charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte v1[] \u003d value;\n        byte v2[] \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            int n \u003d v1.length;\n            for (int i \u003d 0; i \u003c n; i++) {\n                if (v1[i] !\u003d v2[i]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n        return true;\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte v1[] \u003d value;\n        byte v2[] \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte v1[] \u003d s1.value;\n            byte v2[] \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (!isLatin1() \u0026\u0026 (len \u003e 0)) {\n                toffset \u003d toffset \u003c\u003c 1;\n                ooffset \u003d ooffset \u003c\u003c 1;\n                len \u003d len \u003c\u003c 1;\n            }\n            while (len-- \u003e 0) {\n                if (tv[toffset++] !\u003d ov[ooffset++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte ta[] \u003d value;\n        byte pa[] \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            int to \u003d (coder \u003d\u003d LATIN1) ? toffset : toffset \u003c\u003c 1;\n            while (po \u003c pc) {\n                if (ta[to++] !\u003d pa[po++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n                          : StringUTF16.indexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        byte[] tgt    \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount  \u003d tgtStr.length();\n\n        if (fromIndex \u003e\u003d srcCount) {\n            return (tgtCount \u003d\u003d 0 ? srcCount : -1);\n        }\n        if (fromIndex \u003c 0) {\n            fromIndex \u003d 0;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (tgtCount \u003e srcCount) {\n            return -1;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n             \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n             (regex.length() \u003d\u003d 2 \u0026\u0026\n              regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n              (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n            (ch \u003c Character.MIN_HIGH_SURROGATE ||\n             ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            int off \u003d 0;\n            int next \u003d 0;\n            boolean limited \u003d limit \u003e 0;\n            ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n            while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n                if (!limited || list.size() \u003c limit - 1) {\n                    list.add(substring(off, next));\n                    off \u003d next + 1;\n                } else {    // last one\n                    //assert (list.size() \u003d\u003d limit - 1);\n                    int last \u003d length();\n                    list.add(substring(off, last));\n                    off \u003d last;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off \u003d\u003d 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() \u003c limit)\n                list.add(substring(off, length()));\n\n            // Construct result\n            int resultSize \u003d list.size();\n            if (limit \u003d\u003d 0) {\n                while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                    resultSize--;\n                }\n            }\n            String[] result \u003d new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop wil add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of lowercase  mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This is equivalent to calling\n     * {@code toLowerCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\n     *\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a \u003ca\n     * href\u003d\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\n     * point\u003c/a\u003e is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        int copied \u003d len;\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            System.arraycopy(multiple, 0, multiple, copied, copied);\n        }\n        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n        return new String(multiple, coder);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            if (COMPACT_STRINGS) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        if (index \u003c 0 || index \u003e\u003d length) {\n            throw new StringIndexOutOfBoundsException(\"index \" + index +\n                                                      \", length \" + length);\n        }\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        if (offset \u003c 0 || offset \u003e length) {\n            throw new StringIndexOutOfBoundsException(\"offset \" + offset +\n                                                      \", length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static void checkBoundsOffCount(int offset, int count, int length) {\n        if (offset \u003c 0 || count \u003c 0 || offset \u003e length - count) {\n            throw new StringIndexOutOfBoundsException(\n                \"offset \" + offset + \", count \" + count + \", length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        if (begin \u003c 0 || begin \u003e end || end \u003e length) {\n            throw new StringIndexOutOfBoundsException(\n                \"begin \" + begin + \", end \" + end + \", length \" + length);\n        }\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 11:16:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.02 11:16:02 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:16:02 INFO  time: compiled scala_f4dd477a3a in 0.83s
2024.10.02 11:16:34 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:16:34 INFO  time: compiled scala_f4dd477a3a in 0.22s
2024.10.02 11:16:38 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:16:38 INFO  time: compiled scala_f4dd477a3a in 0.22s
2024.10.02 11:16:56 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:16:56 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 11:16:58 WARN  Using indexes to guess the definition of tooString
2024.10.02 11:17:10 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:17:10 INFO  time: compiled scala_f4dd477a3a in 0.19s
2024.10.02 11:17:13 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:17:13 INFO  time: compiled scala_f4dd477a3a in 0.19s
2024.10.02 11:17:30 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:17:30 INFO  time: compiled scala_f4dd477a3a in 0.18s
Oct 02, 2024 11:17:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 11:17:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.02 11:17:42 INFO  compiling scala_f4dd477a3a (26 scala sources)
Oct 02, 2024 11:17:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:17:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.02 11:17:42 INFO  time: compiled scala_f4dd477a3a in 0.2s
Oct 02, 2024 11:17:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:17:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.02 11:17:54 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:17:54 INFO  time: compiled scala_f4dd477a3a in 0.16s
Oct 02, 2024 11:18:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 694
2024.10.02 11:18:02 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:18:02 INFO  time: compiled scala_f4dd477a3a in 0.14s
2024.10.02 11:18:15 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:18:15 INFO  time: compiled scala_f4dd477a3a in 0.16s
2024.10.02 11:18:17 INFO  compiling scala_f4dd477a3a (26 scala sources)
2024.10.02 11:18:20 INFO  time: compiled scala_f4dd477a3a in 3.52s
2024.10.02 11:18:40 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:18:40 INFO  time: compiled scala_f4dd477a3a in 0.35s
2024.10.02 11:18:45 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:18:45 INFO  time: compiled scala_f4dd477a3a in 0.34s
2024.10.02 11:20:43 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:20:43 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:20:43 INFO  Cancelling compilation on scala-cli server
2024.10.02 11:20:43 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:20:43 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 11:20:43 INFO  time: compiled scala_f4dd477a3a in 0.37s
2024.10.02 11:20:44 INFO  time: Imported build in 0.45s
2024.10.02 11:20:44 INFO  running doctor check
2024.10.02 11:20:44 INFO  java targets: scala_f4dd477a3a-test, scala_f4dd477a3a
2024.10.02 11:20:44 INFO  time: indexed workspace in 0.92s
Oct 02, 2024 11:20:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:20:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:20:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:20:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:22:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:06 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:22:08 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:22:08 INFO  time: compiled scala_f4dd477a3a in 0.31s
Oct 02, 2024 11:22:24 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:24 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:24 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:22:24 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:23:29 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:23:29 INFO  time: compiled scala_f4dd477a3a in 0.31s
Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:25:11 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:25:16 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:25:16 INFO  time: compiled scala_f4dd477a3a in 0.3s
Oct 02, 2024 11:27:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:27:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:27:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:27:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:31:57 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:32:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:32:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:32:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:32:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:32:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:32:01 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:32:36 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:32:36 INFO  time: compiled scala_f4dd477a3a in 0.32s
2024.10.02 11:32:45 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:32:45 INFO  time: compiled scala_f4dd477a3a in 0.23s
Oct 02, 2024 11:34:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1245
2024.10.02 11:35:51 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:35:51 INFO  time: compiled scala_f4dd477a3a in 0.38s
2024.10.02 11:35:58 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:35:58 INFO  time: compiled scala_f4dd477a3a in 0.23s
2024.10.02 11:40:23 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:40:23 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 11:40:31 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:40:31 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 11:40:48 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:40:48 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:40:48 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:40:48 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:40:57 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:40:57 INFO  time: compiled scala_f4dd477a3a in 0.22s
Oct 02, 2024 11:41:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:41:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.02 11:41:04 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:41:04 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 11:41:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:41:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:41:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:41:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:41:35 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:41:35 INFO  time: compiled scala_f4dd477a3a in 0.22s
2024.10.02 11:41:40 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:41:40 INFO  time: compiled scala_f4dd477a3a in 0.27s
Oct 02, 2024 11:45:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1905
2024.10.02 11:45:08 INFO  compiling scala_f4dd477a3a (1 scala source)
Oct 02, 2024 11:45:08 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:45:08 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:45:08 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:45:08 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:45:08 INFO  time: compiled scala_f4dd477a3a in 0.24s
2024.10.02 11:45:26 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:45:26 INFO  time: compiled scala_f4dd477a3a in 0.26s
2024.10.02 11:46:40 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:46:40 INFO  time: compiled scala_f4dd477a3a in 0.24s
2024.10.02 11:46:48 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:46:48 INFO  time: compiled scala_f4dd477a3a in 0.52s
Oct 02, 2024 11:47:41 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:47:41 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:47:41 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:47:41 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:48:18 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:48:18 INFO  time: compiled scala_f4dd477a3a in 0.21s
2024.10.02 11:48:32 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:48:32 INFO  time: compiled scala_f4dd477a3a in 75ms
Oct 02, 2024 11:48:46 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:48:46 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:48:46 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:48:46 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:48:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Thread.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.WeakReference;\nimport java.security.AccessController;\nimport java.security.AccessControlContext;\nimport java.security.PrivilegedAction;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.LockSupport;\n\nimport jdk.internal.misc.TerminatingThreadLocal;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * A \u003ci\u003ethread\u003c/i\u003e is a thread of execution in a program. The Java\n * Virtual Machine allows an application to have multiple threads of\n * execution running concurrently.\n * \u003cp\u003e\n * Every thread has a priority. Threads with higher priority are\n * executed in preference to threads with lower priority. Each thread\n * may or may not also be marked as a daemon. When code running in\n * some thread creates a new {@code Thread} object, the new\n * thread has its priority initially set equal to the priority of the\n * creating thread, and is a daemon thread if and only if the\n * creating thread is a daemon.\n * \u003cp\u003e\n * When a Java Virtual Machine starts up, there is usually a single\n * non-daemon thread (which typically calls the method named\n * {@code main} of some designated class). The Java Virtual\n * Machine continues to execute threads until either of the following\n * occurs:\n * \u003cul\u003e\n * \u003cli\u003eThe {@code exit} method of class {@code Runtime} has been\n *     called and the security manager has permitted the exit operation\n *     to take place.\n * \u003cli\u003eAll threads that are not daemon threads have died, either by\n *     returning from the call to the {@code run} method or by\n *     throwing an exception that propagates beyond the {@code run}\n *     method.\n * \u003c/ul\u003e\n * \u003cp\u003e\n * There are two ways to create a new thread of execution. One is to\n * declare a class to be a subclass of {@code Thread}. This\n * subclass should override the {@code run} method of class\n * {@code Thread}. An instance of the subclass can then be\n * allocated and started. For example, a thread that computes primes\n * larger than a stated value could be written as follows:\n * \u003chr\u003e\u003cblockquote\u003e\u003cpre\u003e\n *     class PrimeThread extends Thread {\n *         long minPrime;\n *         PrimeThread(long minPrime) {\n *             this.minPrime \u003d minPrime;\n *         }\n *\n *         public void run() {\n *             // compute primes larger than minPrime\n *             \u0026nbsp;.\u0026nbsp;.\u0026nbsp;.\n *         }\n *     }\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003chr\u003e\n * \u003cp\u003e\n * The following code would then create a thread and start it running:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     PrimeThread p \u003d new PrimeThread(143);\n *     p.start();\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The other way to create a thread is to declare a class that\n * implements the {@code Runnable} interface. That class then\n * implements the {@code run} method. An instance of the class can\n * then be allocated, passed as an argument when creating\n * {@code Thread}, and started. The same example in this other\n * style looks like the following:\n * \u003chr\u003e\u003cblockquote\u003e\u003cpre\u003e\n *     class PrimeRun implements Runnable {\n *         long minPrime;\n *         PrimeRun(long minPrime) {\n *             this.minPrime \u003d minPrime;\n *         }\n *\n *         public void run() {\n *             // compute primes larger than minPrime\n *             \u0026nbsp;.\u0026nbsp;.\u0026nbsp;.\n *         }\n *     }\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003chr\u003e\n * \u003cp\u003e\n * The following code would then create a thread and start it running:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     PrimeRun p \u003d new PrimeRun(143);\n *     new Thread(p).start();\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * Every thread has a name for identification purposes. More than\n * one thread may have the same name. If a name is not specified when\n * a thread is created, a new name is generated for it.\n * \u003cp\u003e\n * Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * @see     Runnable\n * @see     Runtime#exit(int)\n * @see     #run()\n * @see     #stop()\n * @since   1.0\n */\npublic class Thread implements Runnable {\n    /* Make sure registerNatives is the first thing \u003cclinit\u003e does. */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    private volatile String name;\n    private int priority;\n\n    /* Whether or not the thread is a daemon thread. */\n    private boolean daemon \u003d false;\n\n    /* Interrupt state of the thread - read/written directly by JVM */\n    private volatile boolean interrupted;\n\n    /* Fields reserved for exclusive use by the JVM */\n    private boolean stillborn \u003d false;\n    private long eetop;\n\n    /* What will be run. */\n    private Runnable target;\n\n    /* The group of this thread */\n    private ThreadGroup group;\n\n    /* The context ClassLoader for this thread */\n    private ClassLoader contextClassLoader;\n\n    /* The inherited AccessControlContext of this thread */\n    @SuppressWarnings(\"removal\")\n    private AccessControlContext inheritedAccessControlContext;\n\n    /* For autonumbering anonymous threads. */\n    private static int threadInitNumber;\n    private static synchronized int nextThreadNum() {\n        return threadInitNumber++;\n    }\n\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals \u003d null;\n\n    /*\n     * InheritableThreadLocal values pertaining to this thread. This map is\n     * maintained by the InheritableThreadLocal class.\n     */\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals \u003d null;\n\n    /*\n     * The requested stack size for this thread, or 0 if the creator did\n     * not specify a stack size.  It is up to the VM to do whatever it\n     * likes with this number; some VMs will ignore it.\n     */\n    private final long stackSize;\n\n    /*\n     * Thread ID\n     */\n    private final long tid;\n\n    /* For generating thread ID */\n    private static long threadSeqNumber;\n\n    private static synchronized long nextThreadID() {\n        return ++threadSeqNumber;\n    }\n\n    /*\n     * Java thread status for tools, default indicates thread \u0027not yet started\u0027\n     */\n    private volatile int threadStatus;\n\n    /**\n     * The argument supplied to the current call to\n     * java.util.concurrent.locks.LockSupport.park.\n     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker\n     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker\n     */\n    volatile Object parkBlocker;\n\n    /* The object in which this thread is blocked in an interruptible I/O\n     * operation, if any.  The blocker\u0027s interrupt method should be invoked\n     * after setting this thread\u0027s interrupt status.\n     */\n    private volatile Interruptible blocker;\n    private final Object blockerLock \u003d new Object();\n\n    /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets\n     * from java.nio code\n     */\n    static void blockedOn(Interruptible b) {\n        Thread me \u003d Thread.currentThread();\n        synchronized (me.blockerLock) {\n            me.blocker \u003d b;\n        }\n    }\n\n    /**\n     * The minimum priority that a thread can have.\n     */\n    public static final int MIN_PRIORITY \u003d 1;\n\n    /**\n     * The default priority that is assigned to a thread.\n     */\n    public static final int NORM_PRIORITY \u003d 5;\n\n    /**\n     * The maximum priority that a thread can have.\n     */\n    public static final int MAX_PRIORITY \u003d 10;\n\n    /**\n     * Returns a reference to the currently executing thread object.\n     *\n     * @return  the currently executing thread.\n     */\n    @IntrinsicCandidate\n    public static native Thread currentThread();\n\n    /**\n     * A hint to the scheduler that the current thread is willing to yield\n     * its current use of a processor. The scheduler is free to ignore this\n     * hint.\n     *\n     * \u003cp\u003e Yield is a heuristic attempt to improve relative progression\n     * between threads that would otherwise over-utilise a CPU. Its use\n     * should be combined with detailed profiling and benchmarking to\n     * ensure that it actually has the desired effect.\n     *\n     * \u003cp\u003e It is rarely appropriate to use this method. It may be useful\n     * for debugging or testing purposes, where it may help to reproduce\n     * bugs due to race conditions. It may also be useful when designing\n     * concurrency control constructs such as the ones in the\n     * {@link java.util.concurrent.locks} package.\n     */\n    public static native void yield();\n\n    /**\n     * Causes the currently executing thread to sleep (temporarily cease\n     * execution) for the specified number of milliseconds, subject to\n     * the precision and accuracy of system timers and schedulers. The thread\n     * does not lose ownership of any monitors.\n     *\n     * @param  millis\n     *         the length of time to sleep in milliseconds\n     *\n     * @throws  IllegalArgumentException\n     *          if the value of {@code millis} is negative\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\n     *          cleared when this exception is thrown.\n     */\n    public static native void sleep(long millis) throws InterruptedException;\n\n    /**\n     * Causes the currently executing thread to sleep (temporarily cease\n     * execution) for the specified number of milliseconds plus the specified\n     * number of nanoseconds, subject to the precision and accuracy of system\n     * timers and schedulers. The thread does not lose ownership of any\n     * monitors.\n     *\n     * @param  millis\n     *         the length of time to sleep in milliseconds\n     *\n     * @param  nanos\n     *         {@code 0-999999} additional nanoseconds to sleep\n     *\n     * @throws  IllegalArgumentException\n     *          if the value of {@code millis} is negative, or the value of\n     *          {@code nanos} is not in the range {@code 0-999999}\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\n     *          cleared when this exception is thrown.\n     */\n    public static void sleep(long millis, int nanos)\n    throws InterruptedException {\n        if (millis \u003c 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (nanos \u003c 0 || nanos \u003e 999999) {\n            throw new IllegalArgumentException(\n                                \"nanosecond timeout value out of range\");\n        }\n\n        if (nanos \u003e 0 \u0026\u0026 millis \u003c Long.MAX_VALUE) {\n            millis++;\n        }\n\n        sleep(millis);\n    }\n\n    /**\n     * Indicates that the caller is momentarily unable to progress, until the\n     * occurrence of one or more actions on the part of other activities. By\n     * invoking this method within each iteration of a spin-wait loop construct,\n     * the calling thread indicates to the runtime that it is busy-waiting.\n     * The runtime may take action to improve the performance of invoking\n     * spin-wait loop constructions.\n     *\n     * @apiNote\n     * As an example consider a method in a class that spins in a loop until\n     * some flag is set outside of that method. A call to the {@code onSpinWait}\n     * method should be placed inside the spin loop.\n     * \u003cpre\u003e{@code\n     *     class EventHandler {\n     *         volatile boolean eventNotificationNotReceived;\n     *         void waitForEventAndHandleIt() {\n     *             while ( eventNotificationNotReceived ) {\n     *                 java.lang.Thread.onSpinWait();\n     *             }\n     *             readAndProcessEvent();\n     *         }\n     *\n     *         void readAndProcessEvent() {\n     *             // Read event from some source and process it\n     *              . . .\n     *         }\n     *     }\n     * }\u003c/pre\u003e\n     * \u003cp\u003e\n     * The code above would remain correct even if the {@code onSpinWait}\n     * method was not called at all. However on some architectures the Java\n     * Virtual Machine may issue the processor instructions to address such\n     * code patterns in a more beneficial way.\n     *\n     * @since 9\n     */\n    @IntrinsicCandidate\n    public static void onSpinWait() {}\n\n    /**\n     * Initializes a Thread.\n     *\n     * @param g the Thread group\n     * @param target the object whose run() method gets called\n     * @param name the name of the new Thread\n     * @param stackSize the desired stack size for the new thread, or\n     *        zero to indicate that this parameter is to be ignored.\n     * @param acc the AccessControlContext to inherit, or\n     *            AccessController.getContext() if null\n     * @param inheritThreadLocals if {@code true}, inherit initial values for\n     *            inheritable thread-locals from the constructing thread\n     */\n    @SuppressWarnings(\"removal\")\n    private Thread(ThreadGroup g, Runnable target, String name,\n                   long stackSize, AccessControlContext acc,\n                   boolean inheritThreadLocals) {\n        if (name \u003d\u003d null) {\n            throw new NullPointerException(\"name cannot be null\");\n        }\n\n        this.name \u003d name;\n\n        Thread parent \u003d currentThread();\n        SecurityManager security \u003d System.getSecurityManager();\n        if (g \u003d\u003d null) {\n            /* Determine if it\u0027s an applet or not */\n\n            /* If there is a security manager, ask the security manager\n               what to do. */\n            if (security !\u003d null) {\n                g \u003d security.getThreadGroup();\n            }\n\n            /* If the security manager doesn\u0027t have a strong opinion\n               on the matter, use the parent thread group. */\n            if (g \u003d\u003d null) {\n                g \u003d parent.getThreadGroup();\n            }\n        }\n\n        /* checkAccess regardless of whether or not threadgroup is\n           explicitly passed in. */\n        g.checkAccess();\n\n        /*\n         * Do we have the required permissions?\n         */\n        if (security !\u003d null) {\n            if (isCCLOverridden(getClass())) {\n                security.checkPermission(\n                        SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);\n            }\n        }\n\n        g.addUnstarted();\n\n        this.group \u003d g;\n        this.daemon \u003d parent.isDaemon();\n        this.priority \u003d parent.getPriority();\n        if (security \u003d\u003d null || isCCLOverridden(parent.getClass()))\n            this.contextClassLoader \u003d parent.getContextClassLoader();\n        else\n            this.contextClassLoader \u003d parent.contextClassLoader;\n        this.inheritedAccessControlContext \u003d\n                acc !\u003d null ? acc : AccessController.getContext();\n        this.target \u003d target;\n        setPriority(priority);\n        if (inheritThreadLocals \u0026\u0026 parent.inheritableThreadLocals !\u003d null)\n            this.inheritableThreadLocals \u003d\n                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n        /* Stash the specified stack size in case the VM cares */\n        this.stackSize \u003d stackSize;\n\n        /* Set thread ID */\n        this.tid \u003d nextThreadID();\n    }\n\n    /**\n     * Throws CloneNotSupportedException as a Thread can not be meaningfully\n     * cloned. Construct a new Thread instead.\n     *\n     * @throws  CloneNotSupportedException\n     *          always\n     */\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }\n\n    /**\n     * Allocates a new {@code Thread} object. This constructor has the same\n     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}\n     * {@code (null, null, gname)}, where {@code gname} is a newly generated\n     * name. Automatically generated names are of the form\n     * {@code \"Thread-\"+}\u003ci\u003en\u003c/i\u003e, where \u003ci\u003en\u003c/i\u003e is an integer.\n     */\n    public Thread() {\n        this(null, null, \"Thread-\" + nextThreadNum(), 0);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object. This constructor has the same\n     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}\n     * {@code (null, target, gname)}, where {@code gname} is a newly generated\n     * name. Automatically generated names are of the form\n     * {@code \"Thread-\"+}\u003ci\u003en\u003c/i\u003e, where \u003ci\u003en\u003c/i\u003e is an integer.\n     *\n     * @param  target\n     *         the object whose {@code run} method is invoked when this thread\n     *         is started. If {@code null}, this classes {@code run} method does\n     *         nothing.\n     */\n    public Thread(Runnable target) {\n        this(null, target, \"Thread-\" + nextThreadNum(), 0);\n    }\n\n    /**\n     * Creates a new Thread that inherits the given AccessControlContext\n     * but thread-local variables are not inherited.\n     * This is not a public constructor.\n     */\n    Thread(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n        this(null, target, \"Thread-\" + nextThreadNum(), 0, acc, false);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object. This constructor has the same\n     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}\n     * {@code (group, target, gname)} ,where {@code gname} is a newly generated\n     * name. Automatically generated names are of the form\n     * {@code \"Thread-\"+}\u003ci\u003en\u003c/i\u003e, where \u003ci\u003en\u003c/i\u003e is an integer.\n     *\n     * @param  group\n     *         the thread group. If {@code null} and there is a security\n     *         manager, the group is determined by {@linkplain\n     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.\n     *         If there is not a security manager or {@code\n     *         SecurityManager.getThreadGroup()} returns {@code null}, the group\n     *         is set to the current thread\u0027s thread group.\n     *\n     * @param  target\n     *         the object whose {@code run} method is invoked when this thread\n     *         is started. If {@code null}, this thread\u0027s run method is invoked.\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot create a thread in the specified\n     *          thread group\n     */\n    public Thread(ThreadGroup group, Runnable target) {\n        this(group, target, \"Thread-\" + nextThreadNum(), 0);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object. This constructor has the same\n     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}\n     * {@code (null, null, name)}.\n     *\n     * @param   name\n     *          the name of the new thread\n     */\n    public Thread(String name) {\n        this(null, null, name, 0);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object. This constructor has the same\n     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}\n     * {@code (group, null, name)}.\n     *\n     * @param  group\n     *         the thread group. If {@code null} and there is a security\n     *         manager, the group is determined by {@linkplain\n     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.\n     *         If there is not a security manager or {@code\n     *         SecurityManager.getThreadGroup()} returns {@code null}, the group\n     *         is set to the current thread\u0027s thread group.\n     *\n     * @param  name\n     *         the name of the new thread\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot create a thread in the specified\n     *          thread group\n     */\n    public Thread(ThreadGroup group, String name) {\n        this(group, null, name, 0);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object. This constructor has the same\n     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}\n     * {@code (null, target, name)}.\n     *\n     * @param  target\n     *         the object whose {@code run} method is invoked when this thread\n     *         is started. If {@code null}, this thread\u0027s run method is invoked.\n     *\n     * @param  name\n     *         the name of the new thread\n     */\n    public Thread(Runnable target, String name) {\n        this(null, target, name, 0);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object so that it has {@code target}\n     * as its run object, has the specified {@code name} as its name,\n     * and belongs to the thread group referred to by {@code group}.\n     *\n     * \u003cp\u003eIf there is a security manager, its\n     * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}\n     * method is invoked with the ThreadGroup as its argument.\n     *\n     * \u003cp\u003eIn addition, its {@code checkPermission} method is invoked with\n     * the {@code RuntimePermission(\"enableContextClassLoaderOverride\")}\n     * permission when invoked directly or indirectly by the constructor\n     * of a subclass which overrides the {@code getContextClassLoader}\n     * or {@code setContextClassLoader} methods.\n     *\n     * \u003cp\u003eThe priority of the newly created thread is set equal to the\n     * priority of the thread creating it, that is, the currently running\n     * thread. The method {@linkplain #setPriority setPriority} may be\n     * used to change the priority to a new value.\n     *\n     * \u003cp\u003eThe newly created thread is initially marked as being a daemon\n     * thread if and only if the thread creating it is currently marked\n     * as a daemon thread. The method {@linkplain #setDaemon setDaemon}\n     * may be used to change whether or not a thread is a daemon.\n     *\n     * @param  group\n     *         the thread group. If {@code null} and there is a security\n     *         manager, the group is determined by {@linkplain\n     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.\n     *         If there is not a security manager or {@code\n     *         SecurityManager.getThreadGroup()} returns {@code null}, the group\n     *         is set to the current thread\u0027s thread group.\n     *\n     * @param  target\n     *         the object whose {@code run} method is invoked when this thread\n     *         is started. If {@code null}, this thread\u0027s run method is invoked.\n     *\n     * @param  name\n     *         the name of the new thread\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot create a thread in the specified\n     *          thread group or cannot override the context class loader methods.\n     */\n    public Thread(ThreadGroup group, Runnable target, String name) {\n        this(group, target, name, 0);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object so that it has {@code target}\n     * as its run object, has the specified {@code name} as its name,\n     * and belongs to the thread group referred to by {@code group}, and has\n     * the specified \u003ci\u003estack size\u003c/i\u003e.\n     *\n     * \u003cp\u003eThis constructor is identical to {@link\n     * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact\n     * that it allows the thread stack size to be specified.  The stack size\n     * is the approximate number of bytes of address space that the virtual\n     * machine is to allocate for this thread\u0027s stack.  \u003cb\u003eThe effect of the\n     * {@code stackSize} parameter, if any, is highly platform dependent.\u003c/b\u003e\n     *\n     * \u003cp\u003eOn some platforms, specifying a higher value for the\n     * {@code stackSize} parameter may allow a thread to achieve greater\n     * recursion depth before throwing a {@link StackOverflowError}.\n     * Similarly, specifying a lower value may allow a greater number of\n     * threads to exist concurrently without throwing an {@link\n     * OutOfMemoryError} (or other internal error).  The details of\n     * the relationship between the value of the {@code stackSize} parameter\n     * and the maximum recursion depth and concurrency level are\n     * platform-dependent.  \u003cb\u003eOn some platforms, the value of the\n     * {@code stackSize} parameter may have no effect whatsoever.\u003c/b\u003e\n     *\n     * \u003cp\u003eThe virtual machine is free to treat the {@code stackSize}\n     * parameter as a suggestion.  If the specified value is unreasonably low\n     * for the platform, the virtual machine may instead use some\n     * platform-specific minimum value; if the specified value is unreasonably\n     * high, the virtual machine may instead use some platform-specific\n     * maximum.  Likewise, the virtual machine is free to round the specified\n     * value up or down as it sees fit (or to ignore it completely).\n     *\n     * \u003cp\u003eSpecifying a value of zero for the {@code stackSize} parameter will\n     * cause this constructor to behave exactly like the\n     * {@code Thread(ThreadGroup, Runnable, String)} constructor.\n     *\n     * \u003cp\u003e\u003ci\u003eDue to the platform-dependent nature of the behavior of this\n     * constructor, extreme care should be exercised in its use.\n     * The thread stack size necessary to perform a given computation will\n     * likely vary from one JRE implementation to another.  In light of this\n     * variation, careful tuning of the stack size parameter may be required,\n     * and the tuning may need to be repeated for each JRE implementation on\n     * which an application is to run.\u003c/i\u003e\n     *\n     * \u003cp\u003eImplementation note: Java platform implementers are encouraged to\n     * document their implementation\u0027s behavior with respect to the\n     * {@code stackSize} parameter.\n     *\n     *\n     * @param  group\n     *         the thread group. If {@code null} and there is a security\n     *         manager, the group is determined by {@linkplain\n     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.\n     *         If there is not a security manager or {@code\n     *         SecurityManager.getThreadGroup()} returns {@code null}, the group\n     *         is set to the current thread\u0027s thread group.\n     *\n     * @param  target\n     *         the object whose {@code run} method is invoked when this thread\n     *         is started. If {@code null}, this thread\u0027s run method is invoked.\n     *\n     * @param  name\n     *         the name of the new thread\n     *\n     * @param  stackSize\n     *         the desired stack size for the new thread, or zero to indicate\n     *         that this parameter is to be ignored.\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot create a thread in the specified\n     *          thread group\n     *\n     * @since 1.4\n     */\n    public Thread(ThreadGroup group, Runnable target, String name,\n                  long stackSize) {\n        this(group, target, name, stackSize, null, true);\n    }\n\n    /**\n     * Allocates a new {@code Thread} object so that it has {@code target}\n     * as its run object, has the specified {@code name} as its name,\n     * belongs to the thread group referred to by {@code group}, has\n     * the specified {@code stackSize}, and inherits initial values for\n     * {@linkplain InheritableThreadLocal inheritable thread-local} variables\n     * if {@code inheritThreadLocals} is {@code true}.\n     *\n     * \u003cp\u003e This constructor is identical to {@link\n     * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to\n     * suppress, or not, the inheriting of initial values for inheritable\n     * thread-local variables from the constructing thread. This allows for\n     * finer grain control over inheritable thread-locals. Care must be taken\n     * when passing a value of {@code false} for {@code inheritThreadLocals},\n     * as it may lead to unexpected behavior if the new thread executes code\n     * that expects a specific thread-local value to be inherited.\n     *\n     * \u003cp\u003e Specifying a value of {@code true} for the {@code inheritThreadLocals}\n     * parameter will cause this constructor to behave exactly like the\n     * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.\n     *\n     * @param  group\n     *         the thread group. If {@code null} and there is a security\n     *         manager, the group is determined by {@linkplain\n     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.\n     *         If there is not a security manager or {@code\n     *         SecurityManager.getThreadGroup()} returns {@code null}, the group\n     *         is set to the current thread\u0027s thread group.\n     *\n     * @param  target\n     *         the object whose {@code run} method is invoked when this thread\n     *         is started. If {@code null}, this thread\u0027s run method is invoked.\n     *\n     * @param  name\n     *         the name of the new thread\n     *\n     * @param  stackSize\n     *         the desired stack size for the new thread, or zero to indicate\n     *         that this parameter is to be ignored\n     *\n     * @param  inheritThreadLocals\n     *         if {@code true}, inherit initial values for inheritable\n     *         thread-locals from the constructing thread, otherwise no initial\n     *         values are inherited\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot create a thread in the specified\n     *          thread group\n     *\n     * @since 9\n     */\n    public Thread(ThreadGroup group, Runnable target, String name,\n                  long stackSize, boolean inheritThreadLocals) {\n        this(group, target, name, stackSize, null, inheritThreadLocals);\n    }\n\n    /**\n     * Causes this thread to begin execution; the Java Virtual Machine\n     * calls the {@code run} method of this thread.\n     * \u003cp\u003e\n     * The result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * {@code start} method) and the other thread (which executes its\n     * {@code run} method).\n     * \u003cp\u003e\n     * It is never legal to start a thread more than once.\n     * In particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * @throws     IllegalThreadStateException  if the thread was already started.\n     * @see        #run()\n     * @see        #stop()\n     */\n    public synchronized void start() {\n        /**\n         * This method is not invoked for the main method thread or \"system\"\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         *\n         * A zero status value corresponds to state \"NEW\".\n         */\n        if (threadStatus !\u003d 0)\n            throw new IllegalThreadStateException();\n\n        /* Notify the group that this thread is about to be started\n         * so that it can be added to the group\u0027s list of threads\n         * and the group\u0027s unstarted count can be decremented. */\n        group.add(this);\n\n        boolean started \u003d false;\n        try {\n            start0();\n            started \u003d true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);\n                }\n            } catch (Throwable ignore) {\n                /* do nothing. If start0 threw a Throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n\n    private native void start0();\n\n    /**\n     * If this thread was constructed using a separate\n     * {@code Runnable} run object, then that\n     * {@code Runnable} object\u0027s {@code run} method is called;\n     * otherwise, this method does nothing and returns.\n     * \u003cp\u003e\n     * Subclasses of {@code Thread} should override this method.\n     *\n     * @see     #start()\n     * @see     #stop()\n     * @see     #Thread(ThreadGroup, Runnable, String)\n     */\n    @Override\n    public void run() {\n        if (target !\u003d null) {\n            target.run();\n        }\n    }\n\n    /**\n     * This method is called by the system to give a Thread\n     * a chance to clean up before it actually exits.\n     */\n    private void exit() {\n        if (threadLocals !\u003d null \u0026\u0026 TerminatingThreadLocal.REGISTRY.isPresent()) {\n            TerminatingThreadLocal.threadTerminated();\n        }\n        if (group !\u003d null) {\n            group.threadTerminated(this);\n            group \u003d null;\n        }\n        /* Aggressively null out all reference fields: see bug 4006245 */\n        target \u003d null;\n        /* Speed the release of some of these resources */\n        threadLocals \u003d null;\n        inheritableThreadLocals \u003d null;\n        inheritedAccessControlContext \u003d null;\n        blocker \u003d null;\n        uncaughtExceptionHandler \u003d null;\n    }\n\n    /**\n     * Forces the thread to stop executing.\n     * \u003cp\u003e\n     * If there is a security manager installed, its {@code checkAccess}\n     * method is called with {@code this}\n     * as its argument. This may result in a\n     * {@code SecurityException} being raised (in the current thread).\n     * \u003cp\u003e\n     * If this thread is different from the current thread (that is, the current\n     * thread is trying to stop a thread other than itself), the\n     * security manager\u0027s {@code checkPermission} method (with a\n     * {@code RuntimePermission(\"stopThread\")} argument) is called in\n     * addition.\n     * Again, this may result in throwing a\n     * {@code SecurityException} (in the current thread).\n     * \u003cp\u003e\n     * The thread represented by this thread is forced to stop whatever\n     * it is doing abnormally and to throw a newly created\n     * {@code ThreadDeath} object as an exception.\n     * \u003cp\u003e\n     * It is permitted to stop a thread that has not yet been started.\n     * If the thread is eventually started, it immediately terminates.\n     * \u003cp\u003e\n     * An application should not normally try to catch\n     * {@code ThreadDeath} unless it must do some extraordinary\n     * cleanup operation (note that the throwing of\n     * {@code ThreadDeath} causes {@code finally} clauses of\n     * {@code try} statements to be executed before the thread\n     * officially dies).  If a {@code catch} clause catches a\n     * {@code ThreadDeath} object, it is important to rethrow the\n     * object so that the thread actually dies.\n     * \u003cp\u003e\n     * The top-level error handler that reacts to otherwise uncaught\n     * exceptions does not print out a message or otherwise notify the\n     * application if the uncaught exception is an instance of\n     * {@code ThreadDeath}.\n     *\n     * @throws     SecurityException  if the current thread cannot\n     *             modify this thread.\n     * @see        #interrupt()\n     * @see        #checkAccess()\n     * @see        #run()\n     * @see        #start()\n     * @see        ThreadDeath\n     * @see        ThreadGroup#uncaughtException(Thread,Throwable)\n     * @see        SecurityManager#checkAccess(Thread)\n     * @see        SecurityManager#checkPermission\n     * @deprecated This method is inherently unsafe.  Stopping a thread with\n     *       Thread.stop causes it to unlock all of the monitors that it\n     *       has locked (as a natural consequence of the unchecked\n     *       {@code ThreadDeath} exception propagating up the stack).  If\n     *       any of the objects previously protected by these monitors were in\n     *       an inconsistent state, the damaged objects become visible to\n     *       other threads, potentially resulting in arbitrary behavior.  Many\n     *       uses of {@code stop} should be replaced by code that simply\n     *       modifies some variable to indicate that the target thread should\n     *       stop running.  The target thread should check this variable\n     *       regularly, and return from its run method in an orderly fashion\n     *       if the variable indicates that it is to stop running.  If the\n     *       target thread waits for long periods (on a condition variable,\n     *       for example), the {@code interrupt} method should be used to\n     *       interrupt the wait.\n     *       For more information, see\n     *       \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html\"\u003eWhy\n     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?\u003c/a\u003e.\n     */\n    @Deprecated(since\u003d\"1.2\")\n    public final void stop() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager security \u003d System.getSecurityManager();\n        if (security !\u003d null) {\n            checkAccess();\n            if (this !\u003d Thread.currentThread()) {\n                security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);\n            }\n        }\n        // A zero status value corresponds to \"NEW\", it can\u0027t change to\n        // not-NEW because we hold the lock.\n        if (threadStatus !\u003d 0) {\n            resume(); // Wake up thread if it was suspended; no-op otherwise\n        }\n\n        // The VM can handle all thread states\n        stop0(new ThreadDeath());\n    }\n\n    /**\n     * Interrupts this thread.\n     *\n     * \u003cp\u003e Unless the current thread is interrupting itself, which is\n     * always permitted, the {@link #checkAccess() checkAccess} method\n     * of this thread is invoked, which may cause a {@link\n     * SecurityException} to be thrown.\n     *\n     * \u003cp\u003e If this thread is blocked in an invocation of the {@link\n     * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link\n     * Object#wait(long, int) wait(long, int)} methods of the {@link Object}\n     * class, or of the {@link #join()}, {@link #join(long)}, {@link\n     * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)}\n     * methods of this class, then its interrupt status will be cleared and it\n     * will receive an {@link InterruptedException}.\n     *\n     * \u003cp\u003e If this thread is blocked in an I/O operation upon an {@link\n     * java.nio.channels.InterruptibleChannel InterruptibleChannel}\n     * then the channel will be closed, the thread\u0027s interrupt\n     * status will be set, and the thread will receive a {@link\n     * java.nio.channels.ClosedByInterruptException}.\n     *\n     * \u003cp\u003e If this thread is blocked in a {@link java.nio.channels.Selector}\n     * then the thread\u0027s interrupt status will be set and it will return\n     * immediately from the selection operation, possibly with a non-zero\n     * value, just as if the selector\u0027s {@link\n     * java.nio.channels.Selector#wakeup wakeup} method were invoked.\n     *\n     * \u003cp\u003e If none of the previous conditions hold then this thread\u0027s interrupt\n     * status will be set. \u003c/p\u003e\n     *\n     * \u003cp\u003e Interrupting a thread that is not alive need not have any effect.\n     *\n     * @implNote In the JDK Reference Implementation, interruption of a thread\n     * that is not alive still records that the interrupt request was made and\n     * will report it via {@link #interrupted} and {@link #isInterrupted()}.\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot modify this thread\n     *\n     * @revised 6.0, 14\n     */\n    public void interrupt() {\n        if (this !\u003d Thread.currentThread()) {\n            checkAccess();\n\n            // thread may be blocked in an I/O operation\n            synchronized (blockerLock) {\n                Interruptible b \u003d blocker;\n                if (b !\u003d null) {\n                    interrupted \u003d true;\n                    interrupt0();  // inform VM of interrupt\n                    b.interrupt(this);\n                    return;\n                }\n            }\n        }\n        interrupted \u003d true;\n        // inform VM of interrupt\n        interrupt0();\n    }\n\n    /**\n     * Tests whether the current thread has been interrupted.  The\n     * \u003ci\u003einterrupted status\u003c/i\u003e of the thread is cleared by this method.  In\n     * other words, if this method were to be called twice in succession, the\n     * second call would return false (unless the current thread were\n     * interrupted again, after the first call had cleared its interrupted\n     * status and before the second call had examined it).\n     *\n     * @return  {@code true} if the current thread has been interrupted;\n     *          {@code false} otherwise.\n     * @see #isInterrupted()\n     * @revised 6.0, 14\n     */\n    public static boolean interrupted() {\n        Thread t \u003d currentThread();\n        boolean interrupted \u003d t.interrupted;\n        // We may have been interrupted the moment after we read the field,\n        // so only clear the field if we saw that it was set and will return\n        // true; otherwise we could lose an interrupt.\n        if (interrupted) {\n            t.interrupted \u003d false;\n            clearInterruptEvent();\n        }\n        return interrupted;\n    }\n\n    /**\n     * Tests whether this thread has been interrupted.  The \u003ci\u003einterrupted\n     * status\u003c/i\u003e of the thread is unaffected by this method.\n     *\n     * @return  {@code true} if this thread has been interrupted;\n     *          {@code false} otherwise.\n     * @see     #interrupted()\n     * @revised 6.0, 14\n     */\n    public boolean isInterrupted() {\n        return interrupted;\n    }\n\n    /**\n     * Tests if this thread is alive. A thread is alive if it has\n     * been started and has not yet died.\n     *\n     * @return  {@code true} if this thread is alive;\n     *          {@code false} otherwise.\n     */\n    public final native boolean isAlive();\n\n    /**\n     * Suspends this thread.\n     * \u003cp\u003e\n     * First, the {@code checkAccess} method of this thread is called\n     * with no arguments. This may result in throwing a\n     * {@code SecurityException }(in the current thread).\n     * \u003cp\u003e\n     * If the thread is alive, it is suspended and makes no further\n     * progress unless and until it is resumed.\n     *\n     * @throws     SecurityException  if the current thread cannot modify\n     *             this thread.\n     * @see #checkAccess\n     * @deprecated   This method has been deprecated, as it is\n     *   inherently deadlock-prone.  If the target thread holds a lock on the\n     *   monitor protecting a critical system resource when it is suspended, no\n     *   thread can access this resource until the target thread is resumed. If\n     *   the thread that would resume the target thread attempts to lock this\n     *   monitor prior to calling {@code resume}, deadlock results.  Such\n     *   deadlocks typically manifest themselves as \"frozen\" processes.\n     *   For more information, see\n     *   \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html\"\u003eWhy\n     *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?\u003c/a\u003e.\n     */\n    @Deprecated(since\u003d\"1.2\", forRemoval\u003dtrue)\n    public final void suspend() {\n        checkAccess();\n        suspend0();\n    }\n\n    /**\n     * Resumes a suspended thread.\n     * \u003cp\u003e\n     * First, the {@code checkAccess} method of this thread is called\n     * with no arguments. This may result in throwing a\n     * {@code SecurityException} (in the current thread).\n     * \u003cp\u003e\n     * If the thread is alive but suspended, it is resumed and is\n     * permitted to make progress in its execution.\n     *\n     * @throws     SecurityException  if the current thread cannot modify this\n     *             thread.\n     * @see        #checkAccess\n     * @see        #suspend()\n     * @deprecated This method exists solely for use with {@link #suspend},\n     *     which has been deprecated because it is deadlock-prone.\n     *     For more information, see\n     *     \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html\"\u003eWhy\n     *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?\u003c/a\u003e.\n     */\n    @Deprecated(since\u003d\"1.2\", forRemoval\u003dtrue)\n    public final void resume() {\n        checkAccess();\n        resume0();\n    }\n\n    /**\n     * Changes the priority of this thread.\n     * \u003cp\u003e\n     * First the {@code checkAccess} method of this thread is called\n     * with no arguments. This may result in throwing a {@code SecurityException}.\n     * \u003cp\u003e\n     * Otherwise, the priority of this thread is set to the smaller of\n     * the specified {@code newPriority} and the maximum permitted\n     * priority of the thread\u0027s thread group.\n     *\n     * @param newPriority priority to set this thread to\n     * @throws     IllegalArgumentException  If the priority is not in the\n     *               range {@code MIN_PRIORITY} to\n     *               {@code MAX_PRIORITY}.\n     * @throws     SecurityException  if the current thread cannot modify\n     *               this thread.\n     * @see        #getPriority\n     * @see        #checkAccess()\n     * @see        #getThreadGroup()\n     * @see        #MAX_PRIORITY\n     * @see        #MIN_PRIORITY\n     * @see        ThreadGroup#getMaxPriority()\n     */\n    public final void setPriority(int newPriority) {\n        ThreadGroup g;\n        checkAccess();\n        if (newPriority \u003e MAX_PRIORITY || newPriority \u003c MIN_PRIORITY) {\n            throw new IllegalArgumentException();\n        }\n        if((g \u003d getThreadGroup()) !\u003d null) {\n            if (newPriority \u003e g.getMaxPriority()) {\n                newPriority \u003d g.getMaxPriority();\n            }\n            setPriority0(priority \u003d newPriority);\n        }\n    }\n\n    /**\n     * Returns this thread\u0027s priority.\n     *\n     * @return  this thread\u0027s priority.\n     * @see     #setPriority\n     */\n    public final int getPriority() {\n        return priority;\n    }\n\n    /**\n     * Changes the name of this thread to be equal to the argument {@code name}.\n     * \u003cp\u003e\n     * First the {@code checkAccess} method of this thread is called\n     * with no arguments. This may result in throwing a\n     * {@code SecurityException}.\n     *\n     * @param      name   the new name for this thread.\n     * @throws     SecurityException  if the current thread cannot modify this\n     *             thread.\n     * @see        #getName\n     * @see        #checkAccess()\n     */\n    public final synchronized void setName(String name) {\n        checkAccess();\n        if (name \u003d\u003d null) {\n            throw new NullPointerException(\"name cannot be null\");\n        }\n\n        this.name \u003d name;\n        if (threadStatus !\u003d 0) {\n            setNativeName(name);\n        }\n    }\n\n    /**\n     * Returns this thread\u0027s name.\n     *\n     * @return  this thread\u0027s name.\n     * @see     #setName(String)\n     */\n    public final String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the thread group to which this thread belongs.\n     * This method returns null if this thread has died\n     * (been stopped).\n     *\n     * @return  this thread\u0027s thread group.\n     */\n    public final ThreadGroup getThreadGroup() {\n        return group;\n    }\n\n    /**\n     * Returns an estimate of the number of active threads in the current\n     * thread\u0027s {@linkplain java.lang.ThreadGroup thread group} and its\n     * subgroups. Recursively iterates over all subgroups in the current\n     * thread\u0027s thread group.\n     *\n     * \u003cp\u003e The value returned is only an estimate because the number of\n     * threads may change dynamically while this method traverses internal\n     * data structures, and might be affected by the presence of certain\n     * system threads. This method is intended primarily for debugging\n     * and monitoring purposes.\n     *\n     * @return  an estimate of the number of active threads in the current\n     *          thread\u0027s thread group and in any other thread group that\n     *          has the current thread\u0027s thread group as an ancestor\n     */\n    public static int activeCount() {\n        return currentThread().getThreadGroup().activeCount();\n    }\n\n    /**\n     * Copies into the specified array every active thread in the current\n     * thread\u0027s thread group and its subgroups. This method simply\n     * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}\n     * method of the current thread\u0027s thread group.\n     *\n     * \u003cp\u003e An application might use the {@linkplain #activeCount activeCount}\n     * method to get an estimate of how big the array should be, however\n     * \u003ci\u003eif the array is too short to hold all the threads, the extra threads\n     * are silently ignored.\u003c/i\u003e  If it is critical to obtain every active\n     * thread in the current thread\u0027s thread group and its subgroups, the\n     * invoker should verify that the returned int value is strictly less\n     * than the length of {@code tarray}.\n     *\n     * \u003cp\u003e Due to the inherent race condition in this method, it is recommended\n     * that the method only be used for debugging and monitoring purposes.\n     *\n     * @param  tarray\n     *         an array into which to put the list of threads\n     *\n     * @return  the number of threads put into the array\n     *\n     * @throws  SecurityException\n     *          if {@link java.lang.ThreadGroup#checkAccess} determines that\n     *          the current thread cannot access its thread group\n     */\n    public static int enumerate(Thread tarray[]) {\n        return currentThread().getThreadGroup().enumerate(tarray);\n    }\n\n    /**\n     * Throws {@code UnsupportedOperationException}.\n     *\n     * @return     nothing\n     *\n     * @deprecated This method was originally designed to count the number of\n     *             stack frames but the results were never well-defined and it\n     *             depended on thread-suspension.\n     *             This method is subject to removal in a future version of Java SE.\n     * @see        StackWalker\n     */\n    @Deprecated(since\u003d\"1.2\", forRemoval\u003dtrue)\n    public int countStackFrames() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Waits at most {@code millis} milliseconds for this thread to\n     * die. A timeout of {@code 0} means to wait forever.\n     *\n     * \u003cp\u003e This implementation uses a loop of {@code this.wait} calls\n     * conditioned on {@code this.isAlive}. As a thread terminates the\n     * {@code this.notifyAll} method is invoked. It is recommended that\n     * applications not use {@code wait}, {@code notify}, or\n     * {@code notifyAll} on {@code Thread} instances.\n     *\n     * @param  millis\n     *         the time to wait in milliseconds\n     *\n     * @throws  IllegalArgumentException\n     *          if the value of {@code millis} is negative\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\n     *          cleared when this exception is thrown.\n     */\n    public final synchronized void join(final long millis)\n    throws InterruptedException {\n        if (millis \u003e 0) {\n            if (isAlive()) {\n                final long startTime \u003d System.nanoTime();\n                long delay \u003d millis;\n                do {\n                    wait(delay);\n                } while (isAlive() \u0026\u0026 (delay \u003d millis -\n                        TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) \u003e 0);\n            }\n        } else if (millis \u003d\u003d 0) {\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n    }\n\n    /**\n     * Waits at most {@code millis} milliseconds plus\n     * {@code nanos} nanoseconds for this thread to die.\n     * If both arguments are {@code 0}, it means to wait forever.\n     *\n     * \u003cp\u003e This implementation uses a loop of {@code this.wait} calls\n     * conditioned on {@code this.isAlive}. As a thread terminates the\n     * {@code this.notifyAll} method is invoked. It is recommended that\n     * applications not use {@code wait}, {@code notify}, or\n     * {@code notifyAll} on {@code Thread} instances.\n     *\n     * @param  millis\n     *         the time to wait in milliseconds\n     *\n     * @param  nanos\n     *         {@code 0-999999} additional nanoseconds to wait\n     *\n     * @throws  IllegalArgumentException\n     *          if the value of {@code millis} is negative, or the value\n     *          of {@code nanos} is not in the range {@code 0-999999}\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\n     *          cleared when this exception is thrown.\n     */\n    public final synchronized void join(long millis, int nanos)\n    throws InterruptedException {\n\n        if (millis \u003c 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (nanos \u003c 0 || nanos \u003e 999999) {\n            throw new IllegalArgumentException(\n                                \"nanosecond timeout value out of range\");\n        }\n\n        if (nanos \u003e 0 \u0026\u0026 millis \u003c Long.MAX_VALUE) {\n            millis++;\n        }\n\n        join(millis);\n    }\n\n    /**\n     * Waits for this thread to die.\n     *\n     * \u003cp\u003e An invocation of this method behaves in exactly the same\n     * way as the invocation\n     *\n     * \u003cblockquote\u003e\n     * {@linkplain #join(long) join}{@code (0)}\n     * \u003c/blockquote\u003e\n     *\n     * @throws  InterruptedException\n     *          if any thread has interrupted the current thread. The\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\n     *          cleared when this exception is thrown.\n     */\n    public final void join() throws InterruptedException {\n        join(0);\n    }\n\n    /**\n     * Prints a stack trace of the current thread to the standard error stream.\n     * This method is used only for debugging.\n     */\n    public static void dumpStack() {\n        new Exception(\"Stack trace\").printStackTrace();\n    }\n\n    /**\n     * Marks this thread as either a {@linkplain #isDaemon daemon} thread\n     * or a user thread. The Java Virtual Machine exits when the only\n     * threads running are all daemon threads.\n     *\n     * \u003cp\u003e This method must be invoked before the thread is started.\n     *\n     * @param  on\n     *         if {@code true}, marks this thread as a daemon thread\n     *\n     * @throws  IllegalThreadStateException\n     *          if this thread is {@linkplain #isAlive alive}\n     *\n     * @throws  SecurityException\n     *          if {@link #checkAccess} determines that the current\n     *          thread cannot modify this thread\n     */\n    public final void setDaemon(boolean on) {\n        checkAccess();\n        if (isAlive()) {\n            throw new IllegalThreadStateException();\n        }\n        daemon \u003d on;\n    }\n\n    /**\n     * Tests if this thread is a daemon thread.\n     *\n     * @return  {@code true} if this thread is a daemon thread;\n     *          {@code false} otherwise.\n     * @see     #setDaemon(boolean)\n     */\n    public final boolean isDaemon() {\n        return daemon;\n    }\n\n    /**\n     * Determines if the currently running thread has permission to\n     * modify this thread.\n     * \u003cp\u003e\n     * If there is a security manager, its {@code checkAccess} method\n     * is called with this thread as its argument. This may result in\n     * throwing a {@code SecurityException}.\n     *\n     * @throws  SecurityException  if the current thread is not allowed to\n     *          access this thread.\n     * @see        SecurityManager#checkAccess(Thread)\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public final void checkAccess() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager security \u003d System.getSecurityManager();\n        if (security !\u003d null) {\n            security.checkAccess(this);\n        }\n    }\n\n    /**\n     * Returns a string representation of this thread, including the\n     * thread\u0027s name, priority, and thread group.\n     *\n     * @return  a string representation of this thread.\n     */\n    public String toString() {\n        ThreadGroup group \u003d getThreadGroup();\n        if (group !\u003d null) {\n            return \"Thread[\" + getName() + \",\" + getPriority() + \",\" +\n                           group.getName() + \"]\";\n        } else {\n            return \"Thread[\" + getName() + \",\" + getPriority() + \",\" +\n                            \"\" + \"]\";\n        }\n    }\n\n    /**\n     * Returns the context {@code ClassLoader} for this thread. The context\n     * {@code ClassLoader} is provided by the creator of the thread for use\n     * by code running in this thread when loading classes and resources.\n     * If not {@linkplain #setContextClassLoader set}, the default is the\n     * {@code ClassLoader} context of the parent thread. The context\n     * {@code ClassLoader} of the\n     * primordial thread is typically set to the class loader used to load the\n     * application.\n     *\n     *\n     * @return  the context {@code ClassLoader} for this thread, or {@code null}\n     *          indicating the system class loader (or, failing that, the\n     *          bootstrap class loader)\n     *\n     * @throws  SecurityException\n     *          if a security manager is present, and the caller\u0027s class loader\n     *          is not {@code null} and is not the same as or an ancestor of the\n     *          context class loader, and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @since 1.2\n     */\n    @CallerSensitive\n    public ClassLoader getContextClassLoader() {\n        if (contextClassLoader \u003d\u003d null)\n            return null;\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            ClassLoader.checkClassLoaderPermission(contextClassLoader,\n                                                   Reflection.getCallerClass());\n        }\n        return contextClassLoader;\n    }\n\n    /**\n     * Sets the context ClassLoader for this Thread. The context\n     * ClassLoader can be set when a thread is created, and allows\n     * the creator of the thread to provide the appropriate class loader,\n     * through {@code getContextClassLoader}, to code running in the thread\n     * when loading classes and resources.\n     *\n     * \u003cp\u003eIf a security manager is present, its {@link\n     * SecurityManager#checkPermission(java.security.Permission) checkPermission}\n     * method is invoked with a {@link RuntimePermission RuntimePermission}{@code\n     * (\"setContextClassLoader\")} permission to see if setting the context\n     * ClassLoader is permitted.\n     *\n     * @param  cl\n     *         the context ClassLoader for this Thread, or null  indicating the\n     *         system class loader (or, failing that, the bootstrap class loader)\n     *\n     * @throws  SecurityException\n     *          if the current thread cannot set the context ClassLoader\n     *\n     * @since 1.2\n     */\n    public void setContextClassLoader(ClassLoader cl) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n        }\n        contextClassLoader \u003d cl;\n    }\n\n    /**\n     * Returns {@code true} if and only if the current thread holds the\n     * monitor lock on the specified object.\n     *\n     * \u003cp\u003eThis method is designed to allow a program to assert that\n     * the current thread already holds a specified lock:\n     * \u003cpre\u003e\n     *     assert Thread.holdsLock(obj);\n     * \u003c/pre\u003e\n     *\n     * @param  obj the object on which to test lock ownership\n     * @throws NullPointerException if obj is {@code null}\n     * @return {@code true} if the current thread holds the monitor lock on\n     *         the specified object.\n     * @since 1.4\n     */\n    public static native boolean holdsLock(Object obj);\n\n    private static final StackTraceElement[] EMPTY_STACK_TRACE\n        \u003d new StackTraceElement[0];\n\n    /**\n     * Returns an array of stack trace elements representing the stack dump\n     * of this thread.  This method will return a zero-length array if\n     * this thread has not started, has started but has not yet been\n     * scheduled to run by the system, or has terminated.\n     * If the returned array is of non-zero length then the first element of\n     * the array represents the top of the stack, which is the most recent\n     * method invocation in the sequence.  The last element of the array\n     * represents the bottom of the stack, which is the least recent method\n     * invocation in the sequence.\n     *\n     * \u003cp\u003eIf there is a security manager, and this thread is not\n     * the current thread, then the security manager\u0027s\n     * {@code checkPermission} method is called with a\n     * {@code RuntimePermission(\"getStackTrace\")} permission\n     * to see if it\u0027s ok to get the stack trace.\n     *\n     * \u003cp\u003eSome virtual machines may, under some circumstances, omit one\n     * or more stack frames from the stack trace.  In the extreme case,\n     * a virtual machine that has no stack trace information concerning\n     * this thread is permitted to return a zero-length array from this\n     * method.\n     *\n     * @return an array of {@code StackTraceElement},\n     * each represents one stack frame.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        getting the stack trace of thread.\n     * @see SecurityManager#checkPermission\n     * @see RuntimePermission\n     * @see Throwable#getStackTrace\n     *\n     * @since 1.5\n     */\n    public StackTraceElement[] getStackTrace() {\n        if (this !\u003d Thread.currentThread()) {\n            // check for getStackTrace permission\n            @SuppressWarnings(\"removal\")\n            SecurityManager security \u003d System.getSecurityManager();\n            if (security !\u003d null) {\n                security.checkPermission(\n                    SecurityConstants.GET_STACK_TRACE_PERMISSION);\n            }\n            // optimization so we do not call into the vm for threads that\n            // have not yet started or have terminated\n            if (!isAlive()) {\n                return EMPTY_STACK_TRACE;\n            }\n            StackTraceElement[][] stackTraceArray \u003d dumpThreads(new Thread[] {this});\n            StackTraceElement[] stackTrace \u003d stackTraceArray[0];\n            // a thread that was alive during the previous isAlive call may have\n            // since terminated, therefore not having a stacktrace.\n            if (stackTrace \u003d\u003d null) {\n                stackTrace \u003d EMPTY_STACK_TRACE;\n            }\n            return stackTrace;\n        } else {\n            return (new Exception()).getStackTrace();\n        }\n    }\n\n    /**\n     * Returns a map of stack traces for all live threads.\n     * The map keys are threads and each map value is an array of\n     * {@code StackTraceElement} that represents the stack dump\n     * of the corresponding {@code Thread}.\n     * The returned stack traces are in the format specified for\n     * the {@link #getStackTrace getStackTrace} method.\n     *\n     * \u003cp\u003eThe threads may be executing while this method is called.\n     * The stack trace of each thread only represents a snapshot and\n     * each stack trace may be obtained at different time.  A zero-length\n     * array will be returned in the map value if the virtual machine has\n     * no stack trace information about a thread.\n     *\n     * \u003cp\u003eIf there is a security manager, then the security manager\u0027s\n     * {@code checkPermission} method is called with a\n     * {@code RuntimePermission(\"getStackTrace\")} permission as well as\n     * {@code RuntimePermission(\"modifyThreadGroup\")} permission\n     * to see if it is ok to get the stack trace of all threads.\n     *\n     * @return a {@code Map} from {@code Thread} to an array of\n     * {@code StackTraceElement} that represents the stack trace of\n     * the corresponding thread.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        getting the stack trace of thread.\n     * @see #getStackTrace\n     * @see SecurityManager#checkPermission\n     * @see RuntimePermission\n     * @see Throwable#getStackTrace\n     *\n     * @since 1.5\n     */\n    public static Map\u003cThread, StackTraceElement[]\u003e getAllStackTraces() {\n        // check for getStackTrace permission\n        @SuppressWarnings(\"removal\")\n        SecurityManager security \u003d System.getSecurityManager();\n        if (security !\u003d null) {\n            security.checkPermission(\n                SecurityConstants.GET_STACK_TRACE_PERMISSION);\n            security.checkPermission(\n                SecurityConstants.MODIFY_THREADGROUP_PERMISSION);\n        }\n\n        // Get a snapshot of the list of all threads\n        Thread[] threads \u003d getThreads();\n        StackTraceElement[][] traces \u003d dumpThreads(threads);\n        Map\u003cThread, StackTraceElement[]\u003e m \u003d new HashMap\u003c\u003e(threads.length);\n        for (int i \u003d 0; i \u003c threads.length; i++) {\n            StackTraceElement[] stackTrace \u003d traces[i];\n            if (stackTrace !\u003d null) {\n                m.put(threads[i], stackTrace);\n            }\n            // else terminated so we don\u0027t put it in the map\n        }\n        return m;\n    }\n\n    /** cache of subclass security audit results */\n    /* Replace with ConcurrentReferenceHashMap when/if it appears in a future\n     * release */\n    private static class Caches {\n        /** cache of subclass security audit results */\n        static final ConcurrentMap\u003cWeakClassKey,Boolean\u003e subclassAudits \u003d\n            new ConcurrentHashMap\u003c\u003e();\n\n        /** queue for WeakReferences to audited subclasses */\n        static final ReferenceQueue\u003cClass\u003c?\u003e\u003e subclassAuditsQueue \u003d\n            new ReferenceQueue\u003c\u003e();\n    }\n\n    /**\n     * Verifies that this (possibly subclass) instance can be constructed\n     * without violating security constraints: the subclass must not override\n     * security-sensitive non-final methods, or else the\n     * \"enableContextClassLoaderOverride\" RuntimePermission is checked.\n     */\n    private static boolean isCCLOverridden(Class\u003c?\u003e cl) {\n        if (cl \u003d\u003d Thread.class)\n            return false;\n\n        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);\n        WeakClassKey key \u003d new WeakClassKey(cl, Caches.subclassAuditsQueue);\n        Boolean result \u003d Caches.subclassAudits.get(key);\n        if (result \u003d\u003d null) {\n            result \u003d Boolean.valueOf(auditSubclass(cl));\n            Caches.subclassAudits.putIfAbsent(key, result);\n        }\n\n        return result.booleanValue();\n    }\n\n    /**\n     * Performs reflective checks on given subclass to verify that it doesn\u0027t\n     * override security-sensitive non-final methods.  Returns true if the\n     * subclass overrides any of the methods, false otherwise.\n     */\n    private static boolean auditSubclass(final Class\u003c?\u003e subcl) {\n        @SuppressWarnings(\"removal\")\n        Boolean result \u003d AccessController.doPrivileged(\n            new PrivilegedAction\u003c\u003e() {\n                public Boolean run() {\n                    for (Class\u003c?\u003e cl \u003d subcl;\n                         cl !\u003d Thread.class;\n                         cl \u003d cl.getSuperclass())\n                    {\n                        try {\n                            cl.getDeclaredMethod(\"getContextClassLoader\", new Class\u003c?\u003e[0]);\n                            return Boolean.TRUE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                        try {\n                            Class\u003c?\u003e[] params \u003d {ClassLoader.class};\n                            cl.getDeclaredMethod(\"setContextClassLoader\", params);\n                            return Boolean.TRUE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                    }\n                    return Boolean.FALSE;\n                }\n            }\n        );\n        return result.booleanValue();\n    }\n\n    private static native StackTraceElement[][] dumpThreads(Thread[] threads);\n    private static native Thread[] getThreads();\n\n    /**\n     * Returns the identifier of this Thread.  The thread ID is a positive\n     * {@code long} number generated when this thread was created.\n     * The thread ID is unique and remains unchanged during its lifetime.\n     * When a thread is terminated, this thread ID may be reused.\n     *\n     * @return this thread\u0027s ID.\n     * @since 1.5\n     */\n    public long getId() {\n        return tid;\n    }\n\n    /**\n     * A thread state.  A thread can be in one of the following states:\n     * \u003cul\u003e\n     * \u003cli\u003e{@link #NEW}\u003cbr\u003e\n     *     A thread that has not yet started is in this state.\n     *     \u003c/li\u003e\n     * \u003cli\u003e{@link #RUNNABLE}\u003cbr\u003e\n     *     A thread executing in the Java virtual machine is in this state.\n     *     \u003c/li\u003e\n     * \u003cli\u003e{@link #BLOCKED}\u003cbr\u003e\n     *     A thread that is blocked waiting for a monitor lock\n     *     is in this state.\n     *     \u003c/li\u003e\n     * \u003cli\u003e{@link #WAITING}\u003cbr\u003e\n     *     A thread that is waiting indefinitely for another thread to\n     *     perform a particular action is in this state.\n     *     \u003c/li\u003e\n     * \u003cli\u003e{@link #TIMED_WAITING}\u003cbr\u003e\n     *     A thread that is waiting for another thread to perform an action\n     *     for up to a specified waiting time is in this state.\n     *     \u003c/li\u003e\n     * \u003cli\u003e{@link #TERMINATED}\u003cbr\u003e\n     *     A thread that has exited is in this state.\n     *     \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e\n     * A thread can be in only one state at a given point in time.\n     * These states are virtual machine states which do not reflect\n     * any operating system thread states.\n     *\n     * @since   1.5\n     * @see #getState\n     */\n    public enum State {\n        /**\n         * Thread state for a thread which has not yet started.\n         */\n        NEW,\n\n        /**\n         * Thread state for a runnable thread.  A thread in the runnable\n         * state is executing in the Java virtual machine but it may\n         * be waiting for other resources from the operating system\n         * such as processor.\n         */\n        RUNNABLE,\n\n        /**\n         * Thread state for a thread blocked waiting for a monitor lock.\n         * A thread in the blocked state is waiting for a monitor lock\n         * to enter a synchronized block/method or\n         * reenter a synchronized block/method after calling\n         * {@link Object#wait() Object.wait}.\n         */\n        BLOCKED,\n\n        /**\n         * Thread state for a waiting thread.\n         * A thread is in the waiting state due to calling one of the\n         * following methods:\n         * \u003cul\u003e\n         *   \u003cli\u003e{@link Object#wait() Object.wait} with no timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link #join() Thread.join} with no timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link LockSupport#park() LockSupport.park}\u003c/li\u003e\n         * \u003c/ul\u003e\n         *\n         * \u003cp\u003eA thread in the waiting state is waiting for another thread to\n         * perform a particular action.\n         *\n         * For example, a thread that has called {@code Object.wait()}\n         * on an object is waiting for another thread to call\n         * {@code Object.notify()} or {@code Object.notifyAll()} on\n         * that object. A thread that has called {@code Thread.join()}\n         * is waiting for a specified thread to terminate.\n         */\n        WAITING,\n\n        /**\n         * Thread state for a waiting thread with a specified waiting time.\n         * A thread is in the timed waiting state due to calling one of\n         * the following methods with a specified positive waiting time:\n         * \u003cul\u003e\n         *   \u003cli\u003e{@link #sleep Thread.sleep}\u003c/li\u003e\n         *   \u003cli\u003e{@link Object#wait(long) Object.wait} with timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link #join(long) Thread.join} with timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link LockSupport#parkNanos LockSupport.parkNanos}\u003c/li\u003e\n         *   \u003cli\u003e{@link LockSupport#parkUntil LockSupport.parkUntil}\u003c/li\u003e\n         * \u003c/ul\u003e\n         */\n        TIMED_WAITING,\n\n        /**\n         * Thread state for a terminated thread.\n         * The thread has completed execution.\n         */\n        TERMINATED;\n    }\n\n    /**\n     * Returns the state of this thread.\n     * This method is designed for use in monitoring of the system state,\n     * not for synchronization control.\n     *\n     * @return this thread\u0027s state.\n     * @since 1.5\n     */\n    public State getState() {\n        // get current thread state\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n\n    // Added in JSR-166\n\n    /**\n     * Interface for handlers invoked when a {@code Thread} abruptly\n     * terminates due to an uncaught exception.\n     * \u003cp\u003eWhen a thread is about to terminate due to an uncaught exception\n     * the Java Virtual Machine will query the thread for its\n     * {@code UncaughtExceptionHandler} using\n     * {@link #getUncaughtExceptionHandler} and will invoke the handler\u0027s\n     * {@code uncaughtException} method, passing the thread and the\n     * exception as arguments.\n     * If a thread has not had its {@code UncaughtExceptionHandler}\n     * explicitly set, then its {@code ThreadGroup} object acts as its\n     * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object\n     * has no\n     * special requirements for dealing with the exception, it can forward\n     * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler\n     * default uncaught exception handler}.\n     *\n     * @see #setDefaultUncaughtExceptionHandler\n     * @see #setUncaughtExceptionHandler\n     * @see ThreadGroup#uncaughtException\n     * @since 1.5\n     */\n    @FunctionalInterface\n    public interface UncaughtExceptionHandler {\n        /**\n         * Method invoked when the given thread terminates due to the\n         * given uncaught exception.\n         * \u003cp\u003eAny exception thrown by this method will be ignored by the\n         * Java Virtual Machine.\n         * @param t the thread\n         * @param e the exception\n         */\n        void uncaughtException(Thread t, Throwable e);\n    }\n\n    // null unless explicitly set\n    private volatile UncaughtExceptionHandler uncaughtExceptionHandler;\n\n    // null unless explicitly set\n    private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;\n\n    /**\n     * Set the default handler invoked when a thread abruptly terminates\n     * due to an uncaught exception, and no other handler has been defined\n     * for that thread.\n     *\n     * \u003cp\u003eUncaught exception handling is controlled first by the thread, then\n     * by the thread\u0027s {@link ThreadGroup} object and finally by the default\n     * uncaught exception handler. If the thread does not have an explicit\n     * uncaught exception handler set, and the thread\u0027s thread group\n     * (including parent thread groups)  does not specialize its\n     * {@code uncaughtException} method, then the default handler\u0027s\n     * {@code uncaughtException} method will be invoked.\n     * \u003cp\u003eBy setting the default uncaught exception handler, an application\n     * can change the way in which uncaught exceptions are handled (such as\n     * logging to a specific device, or file) for those threads that would\n     * already accept whatever \u0026quot;default\u0026quot; behavior the system\n     * provided.\n     *\n     * \u003cp\u003eNote that the default uncaught exception handler should not usually\n     * defer to the thread\u0027s {@code ThreadGroup} object, as that could cause\n     * infinite recursion.\n     *\n     * @param eh the object to use as the default uncaught exception handler.\n     * If {@code null} then there is no default handler.\n     *\n     * @throws SecurityException if a security manager is present and it denies\n     *         {@link RuntimePermission}{@code (\"setDefaultUncaughtExceptionHandler\")}\n     *\n     * @see #setUncaughtExceptionHandler\n     * @see #getUncaughtExceptionHandler\n     * @see ThreadGroup#uncaughtException\n     * @since 1.5\n     */\n    public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(\n                new RuntimePermission(\"setDefaultUncaughtExceptionHandler\")\n                    );\n        }\n\n         defaultUncaughtExceptionHandler \u003d eh;\n     }\n\n    /**\n     * Returns the default handler invoked when a thread abruptly terminates\n     * due to an uncaught exception. If the returned value is {@code null},\n     * there is no default.\n     * @since 1.5\n     * @see #setDefaultUncaughtExceptionHandler\n     * @return the default uncaught exception handler for all threads\n     */\n    public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){\n        return defaultUncaughtExceptionHandler;\n    }\n\n    /**\n     * Returns the handler invoked when this thread abruptly terminates\n     * due to an uncaught exception. If this thread has not had an\n     * uncaught exception handler explicitly set then this thread\u0027s\n     * {@code ThreadGroup} object is returned, unless this thread\n     * has terminated, in which case {@code null} is returned.\n     * @since 1.5\n     * @return the uncaught exception handler for this thread\n     */\n    public UncaughtExceptionHandler getUncaughtExceptionHandler() {\n        return uncaughtExceptionHandler !\u003d null ?\n            uncaughtExceptionHandler : group;\n    }\n\n    /**\n     * Set the handler invoked when this thread abruptly terminates\n     * due to an uncaught exception.\n     * \u003cp\u003eA thread can take full control of how it responds to uncaught\n     * exceptions by having its uncaught exception handler explicitly set.\n     * If no such handler is set then the thread\u0027s {@code ThreadGroup}\n     * object acts as its handler.\n     * @param eh the object to use as this thread\u0027s uncaught exception\n     * handler. If {@code null} then this thread has no explicit handler.\n     * @throws  SecurityException  if the current thread is not allowed to\n     *          modify this thread.\n     * @see #setDefaultUncaughtExceptionHandler\n     * @see ThreadGroup#uncaughtException\n     * @since 1.5\n     */\n    public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {\n        checkAccess();\n        uncaughtExceptionHandler \u003d eh;\n    }\n\n    /**\n     * Dispatch an uncaught exception to the handler. This method is\n     * intended to be called only by the JVM.\n     */\n    private void dispatchUncaughtException(Throwable e) {\n        getUncaughtExceptionHandler().uncaughtException(this, e);\n    }\n\n    /**\n     * Removes from the specified map any keys that have been enqueued\n     * on the specified reference queue.\n     */\n    static void processQueue(ReferenceQueue\u003cClass\u003c?\u003e\u003e queue,\n                             ConcurrentMap\u003c? extends\n                             WeakReference\u003cClass\u003c?\u003e\u003e, ?\u003e map)\n    {\n        Reference\u003c? extends Class\u003c?\u003e\u003e ref;\n        while((ref \u003d queue.poll()) !\u003d null) {\n            map.remove(ref);\n        }\n    }\n\n    /**\n     *  Weak key for Class objects.\n     **/\n    static class WeakClassKey extends WeakReference\u003cClass\u003c?\u003e\u003e {\n        /**\n         * saved value of the referent\u0027s identity hash code, to maintain\n         * a consistent hash code after the referent has been cleared\n         */\n        private final int hash;\n\n        /**\n         * Create a new WeakClassKey to the given object, registered\n         * with a queue.\n         */\n        WeakClassKey(Class\u003c?\u003e cl, ReferenceQueue\u003cClass\u003c?\u003e\u003e refQueue) {\n            super(cl, refQueue);\n            hash \u003d System.identityHashCode(cl);\n        }\n\n        /**\n         * Returns the identity hash code of the original referent.\n         */\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n\n        /**\n         * Returns true if the given object is this identical\n         * WeakClassKey instance, or, if this object\u0027s referent has not\n         * been cleared, if the given object is another WeakClassKey\n         * instance with the identical non-null referent as this one.\n         */\n        @Override\n        public boolean equals(Object obj) {\n            if (obj \u003d\u003d this)\n                return true;\n\n            if (obj instanceof WeakClassKey) {\n                Class\u003c?\u003e referent \u003d get();\n                return (referent !\u003d null) \u0026\u0026\n                        (((WeakClassKey) obj).refersTo(referent));\n            } else {\n                return false;\n            }\n        }\n    }\n\n\n    // The following three initially uninitialized fields are exclusively\n    // managed by class java.util.concurrent.ThreadLocalRandom. These\n    // fields are used to build the high-performance PRNGs in the\n    // concurrent code, and we can not risk accidental false sharing.\n    // Hence, the fields are isolated with @Contended.\n\n    /** The current seed for a ThreadLocalRandom */\n    @jdk.internal.vm.annotation.Contended(\"tlr\")\n    long threadLocalRandomSeed;\n\n    /** Probe hash value; nonzero if threadLocalRandomSeed initialized */\n    @jdk.internal.vm.annotation.Contended(\"tlr\")\n    int threadLocalRandomProbe;\n\n    /** Secondary seed isolated from public ThreadLocalRandom sequence */\n    @jdk.internal.vm.annotation.Contended(\"tlr\")\n    int threadLocalRandomSecondarySeed;\n\n    /* Some private helper methods */\n    private native void setPriority0(int newPriority);\n    private native void stop0(Object o);\n    private native void suspend0();\n    private native void resume0();\n    private native void interrupt0();\n    private static native void clearInterruptEvent();\n    private native void setNativeName(String name);\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Thread.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Thread.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:48:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Thread.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Thread.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Thread.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.02 11:48:53 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:48:53 INFO  time: compiled scala_f4dd477a3a in 74ms
2024.10.02 11:49:01 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:49:01 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.02 11:52:50 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:52:50 INFO  time: compiled scala_f4dd477a3a in 0.29s
Oct 02, 2024 11:52:58 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:52:58 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:52:58 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:52:58 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:53:11 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:53:11 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 11:53:20 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:53:20 INFO  time: compiled scala_f4dd477a3a in 81ms
Oct 02, 2024 11:53:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2753
2024.10.02 11:53:44 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:53:44 INFO  time: compiled scala_f4dd477a3a in 70ms
2024.10.02 11:53:55 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:53:55 INFO  time: compiled scala_f4dd477a3a in 68ms
Oct 02, 2024 11:54:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:54:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:54:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:54:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:54:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2869
2024.10.02 11:54:17 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:54:17 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 11:54:33 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:54:33 INFO  time: compiled scala_f4dd477a3a in 69ms
2024.10.02 11:54:42 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:54:42 INFO  time: compiled scala_f4dd477a3a in 0.16s
2024.10.02 11:54:59 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:54:59 INFO  time: compiled scala_f4dd477a3a in 0.21s
Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:02 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 11:55:05 AM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 11:55:33 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 11:55:33 INFO  time: compiled scala_f4dd477a3a in 0.26s
Oct 02, 2024 11:55:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:55:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:55:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 11:55:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.02 12:00:04 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:00:04 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 12:00:05 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
Oct 02, 2024 12:00:10 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:00:10 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:00:17 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
Oct 02, 2024 12:00:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3173
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:18 INFO  time: compiled scala_f4dd477a3a in 85ms
2024.10.02 12:00:19 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:25 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:35 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:36 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:37 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:00:37 INFO  time: compiled scala_f4dd477a3a in 0.34s
2024.10.02 12:00:37 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:41 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:41 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:00:41 INFO  time: compiled scala_f4dd477a3a in 0.27s
2024.10.02 12:00:42 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:53 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:56 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:57 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:00:57 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:00:57 INFO  time: compiled scala_f4dd477a3a in 78ms
2024.10.02 12:00:58 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:02 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:02 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:03 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:03 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:05 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:06 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:07 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:08 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:08 WARN  Could not load snapshot text for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala
2024.10.02 12:01:09 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:01:09 INFO  time: compiled scala_f4dd477a3a in 0.14s
Oct 02, 2024 12:01:20 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:20 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:20 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:20 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:20 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:20 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:26 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:26 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:26 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:26 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:01:40 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:01:40 INFO  time: compiled scala_f4dd477a3a in 0.27s
Oct 02, 2024 12:01:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:01:46 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:01:46 INFO  time: compiled scala_f4dd477a3a in 0.15s
Oct 02, 2024 12:01:51 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:51 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:55 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:01:55 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:02:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3515
Oct 02, 2024 12:02:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3549
Oct 02, 2024 12:02:04 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:02:04 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:02:06 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:02:06 INFO  time: compiled scala_f4dd477a3a in 0.22s
2024.10.02 12:02:10 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:02:10 INFO  time: compiled scala_f4dd477a3a in 0.24s
2024.10.02 12:02:22 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:02:22 INFO  time: compiled scala_f4dd477a3a in 0.14s
Oct 02, 2024 12:02:23 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:02:23 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:02:23 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:02:23 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:02:31 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:02:31 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 12:05:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:05:27 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:05:27 INFO  time: compiled scala_f4dd477a3a in 0.28s
Oct 02, 2024 12:05:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:05:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:05:38 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:05:38 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 12:06:20 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:06:20 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 12:06:27 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.SignatureHelpProvider$.$anonfun$2(SignatureHelpProvider.scala:59)
	at scala.collection.immutable.List.map(List.scala:246)
	at dotty.tools.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:68)
	at dotty.tools.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:409)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:06:27 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.SignatureHelpProvider$.$anonfun$2(SignatureHelpProvider.scala:59)
	at scala.collection.immutable.List.map(List.scala:246)
	at dotty.tools.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:68)
	at dotty.tools.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:409)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:06:27 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.SignatureHelpProvider$.$anonfun$2(SignatureHelpProvider.scala:59)
	at scala.collection.immutable.List.map(List.scala:246)
	at dotty.tools.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:68)
	at dotty.tools.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:409)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:06:27 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.SignatureHelpProvider$.$anonfun$2(SignatureHelpProvider.scala:59)
	at scala.collection.immutable.List.map(List.scala:246)
	at dotty.tools.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:68)
	at dotty.tools.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:409)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:06:56 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:06:56 INFO  time: compiled scala_f4dd477a3a in 86ms
2024.10.02 12:06:57 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:06:57 INFO  time: compiled scala_f4dd477a3a in 85ms
Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:07 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:07:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4294
2024.10.02 12:07:54 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:07:54 INFO  time: compiled scala_f4dd477a3a in 0.24s
Oct 02, 2024 12:08:02 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:08:02 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:08:02 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:08:02 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:08:02 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:08:02 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:08:02 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:08:02 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 12:08:11 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:08:11 INFO  time: compiled scala_f4dd477a3a in 0.16s
2024.10.02 12:09:29 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:09:29 INFO  time: compiled scala_f4dd477a3a in 0.19s
Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:29 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:33 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:33 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:33 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:09:33 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:09:43 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:09:43 INFO  time: compiled scala_f4dd477a3a in 0.22s
2024.10.02 12:10:15 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:10:15 INFO  time: compiled scala_f4dd477a3a in 0.3s
2024.10.02 12:10:33 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:10:33 INFO  time: compiled scala_f4dd477a3a in 0.21s
Oct 02, 2024 12:10:50 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:10:50 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:10:50 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:10:50 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:10:53 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:10:53 INFO  time: compiled scala_f4dd477a3a in 0.28s
Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:11:19 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:11:26 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:11:26 INFO  time: compiled scala_f4dd477a3a in 0.35s
2024.10.02 12:12:12 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:12:12 INFO  time: compiled scala_f4dd477a3a in 0.27s
Oct 02, 2024 12:13:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4952
2024.10.02 12:13:32 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:13:32 INFO  time: compiled scala_f4dd477a3a in 0.27s
2024.10.02 12:13:37 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:13:37 INFO  time: compiled scala_f4dd477a3a in 0.21s
2024.10.02 12:14:01 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:14:01 INFO  time: compiled scala_f4dd477a3a in 67ms
2024.10.02 12:14:11 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:14:11 INFO  time: compiled scala_f4dd477a3a in 68ms
2024.10.02 12:14:51 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:14:51 INFO  time: compiled scala_f4dd477a3a in 80ms
2024.10.02 12:15:00 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:15:00 INFO  time: compiled scala_f4dd477a3a in 71ms
Oct 02, 2024 12:16:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5365
2024.10.02 12:16:20 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:16:20 INFO  time: compiled scala_f4dd477a3a in 78ms
2024.10.02 12:16:58 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:16:58 INFO  time: compiled scala_f4dd477a3a in 76ms
2024.10.02 12:17:33 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:17:33 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 12:18:11 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:18:11 INFO  time: compiled scala_f4dd477a3a in 0.2s
Oct 02, 2024 12:18:13 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:13 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:13 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:13 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:13 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:13 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$lzyINIT1$1(ShortenedTypePrinter.scala:312)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramsDocs$1(ShortenedTypePrinter.scala:316)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$6(ShortenedTypePrinter.scala:333)
	at dotty.tools.pc.printer.ShortenedTypePrinter.paramLabel(ShortenedTypePrinter.scala:482)
	at dotty.tools.pc.printer.ShortenedTypePrinter.$anonfun$5(ShortenedTypePrinter.scala:335)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1$$anonfun$1(ShortenedTypePrinter.scala:337)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.printer.ShortenedTypePrinter.label$1(ShortenedTypePrinter.scala:342)
	at dotty.tools.pc.printer.ShortenedTypePrinter.defaultMethodSignature(ShortenedTypePrinter.scala:345)
	at dotty.tools.pc.printer.ShortenedTypePrinter.hoverSymbol(ShortenedTypePrinter.scala:239)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:124)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:18:15 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:18:15 INFO  time: compiled scala_f4dd477a3a in 0.16s
Oct 02, 2024 12:18:43 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:43 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:43 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:43 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5849
Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:18:45 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:19:04 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:19:04 INFO  time: compiled scala_f4dd477a3a in 0.57s
2024.10.02 12:19:21 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:19:21 INFO  time: compiled scala_f4dd477a3a in 0.19s
2024.10.02 12:19:49 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:19:49 INFO  time: compiled scala_f4dd477a3a in 0.15s
2024.10.02 12:20:37 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:20:37 INFO  time: compiled scala_f4dd477a3a in 0.26s
Oct 02, 2024 12:20:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:20:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:20:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:20:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:20:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

Oct 02, 2024 12:20:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\Practise\hello-world\src\main\scala\EM_Main.scala
java.nio.file.NoSuchFileException: D:\Practise\hello-world\src\main\scala\EM_Main.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:428)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:273)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:284)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:295)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:199)
	at scala.collection.immutable.Set$Set2.foreach(Set.scala:210)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:199)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$8(SymbolIndexBucket.scala:222)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:222)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:172)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:129)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:49)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:51)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:44)
	at dotty.tools.pc.utils.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:283)
	at dotty.tools.pc.HoverProvider$.$anonfun$3(HoverProvider.scala:129)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at dotty.tools.pc.HoverProvider$.hover(HoverProvider.scala:129)
	at dotty.tools.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:363)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:157)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:143)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:246)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:153)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.02 12:21:53 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.02 12:21:53 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:21:54 INFO  Running List(C:\Users\Vishwasujit\AppData\Local\Coursier\data\bin\scala-cli.BAT, bsp, --workspace, D:\Practise\hello-world\.metals-scala-cli, --semantic-db-source-root, D:\Practise\hello-world, D:\Practise\hello-world\build.sbt)
2024.10.02 12:21:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practise\hello-world\.metals\bsp.trace.json or C:\Users\Vishwasujit\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.02 12:21:54 INFO  Scala CLI: [error]  D:\Practise\hello-world\build.sbt: unrecognized source type (expected .scala or .sc extension, or a directory).
2024.10.02 12:21:55 INFO  time: code lens generation in 1.94s
2024.10.02 12:22:23 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:22:25 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:22:27 WARN  no build target for: D:\Practise\hello-world\build.sbt
2024.10.02 12:22:27 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:22:29 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:22:29 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:22:29 WARN  no build target for: D:\Practise\hello-world\build.sbt
2024.10.02 12:22:31 INFO  no build target found for D:\Practise\hello-world\build.sbt. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:22:54 ERROR Timeout waiting for 'build/initialize' response
2024.10.02 12:22:54 WARN  Retrying connection to the build server Scala CLI
2024.10.02 12:22:54 INFO  Running List(C:\Users\Vishwasujit\AppData\Local\Coursier\data\bin\scala-cli.BAT, bsp, --workspace, D:\Practise\hello-world\.metals-scala-cli, --semantic-db-source-root, D:\Practise\hello-world, D:\Practise\hello-world\build.sbt)
2024.10.02 12:22:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practise\hello-world\.metals\bsp.trace.json or C:\Users\Vishwasujit\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.02 12:22:54 INFO  Scala CLI: [error]  D:\Practise\hello-world\build.sbt: unrecognized source type (expected .scala or .sc extension, or a directory).
2024.10.02 12:23:22 INFO  Started: Metals version 1.3.5 in folders 'D:\Practise\hello-world\src\main\scala' for client Visual Studio Code 1.93.1.
2024.10.02 12:29:51 INFO  Started: Metals version 1.3.5 in folders 'D:\Practise\hello-world\src\main\scala' for client Visual Studio Code 1.93.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@26c543b5]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@16f1ba65]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@26c543b5]
2024.10.02 12:29:54 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.02 12:29:54 INFO  Attempting to connect to the build server...
2024.10.02 12:29:54 INFO  Running BSP server List(C:\Users\Vishwasujit\AppData\Local\Coursier\data\bin\.scala-cli.aux.exe, bsp, --json-options, D:\Practise\hello-world\src\main\scala\.scala-build\ide-options-v2.json, --json-launcher-options, D:\Practise\hello-world\src\main\scala\.scala-build\ide-launcher-options.json, --envs-file, D:\Practise\hello-world\src\main\scala\.scala-build\ide-envs.json, D:\Practise\hello-world\src\main\scala)
2024.10.02 12:29:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practise\hello-world\src\main\scala\.metals\bsp.trace.json or C:\Users\Vishwasujit\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.02 12:29:55 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:55 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:55 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:55 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
Oct 02, 2024 12:29:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6
2024.10.02 12:29:57 INFO  no build target found for D:\Practise\hello-world\src\main\scala\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.02 12:29:58 INFO  time: Connected to build server in 3.37s
2024.10.02 12:29:58 INFO  Connected to Build server: scala-cli v1.4.3
2024.10.02 12:29:58 INFO  running doctor check
2024.10.02 12:29:58 INFO  java targets: scala_f4dd477a3a-test, scala_f4dd477a3a
2024.10.02 12:29:58 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:29:58 WARN  Invalid text document uri received from build server: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Main.scala
2024.10.02 12:29:58 INFO  time: compiled scala_f4dd477a3a in 0.66s
2024.10.02 12:30:03 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.02 12:30:03 INFO  time: indexed workspace in 5.75s
Oct 02, 2024 12:30:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:30:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Oct 02, 2024 12:36:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 249
2024.10.02 12:36:38 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:36:38 INFO  time: compiled scala_f4dd477a3a in 0.16s
2024.10.02 12:37:00 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:37:00 INFO  time: compiled scala_f4dd477a3a in 76ms
2024.10.02 12:38:26 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:38:26 INFO  time: compiled scala_f4dd477a3a in 79ms
2024.10.02 12:38:38 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 12:38:38 INFO  time: compiled scala_f4dd477a3a in 0.21s
2024.10.02 13:45:10 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 13:45:10 INFO  time: compiled scala_f4dd477a3a in 0.48s
2024.10.02 13:48:15 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 13:48:15 INFO  time: compiled scala_f4dd477a3a in 0.16s
2024.10.02 13:48:28 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 13:48:28 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 13:48:35 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 13:48:35 INFO  time: compiled scala_f4dd477a3a in 0.25s
2024.10.02 14:05:55 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:05:55 INFO  time: compiled scala_f4dd477a3a in 0.33s
2024.10.02 14:06:02 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:06:02 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 14:06:23 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:06:23 INFO  time: compiled scala_f4dd477a3a in 0.18s
Oct 02, 2024 2:06:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1455
2024.10.02 14:06:38 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:06:38 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 2:06:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1524
2024.10.02 14:06:45 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:06:45 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 2:07:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:07:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.02 14:07:16 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:07:16 INFO  time: compiled scala_f4dd477a3a in 0.19s
2024.10.02 14:07:26 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:07:26 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 02, 2024 2:07:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:07:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:07:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:07:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.02 14:07:32 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:07:32 INFO  time: compiled scala_f4dd477a3a in 0.16s
2024.10.02 14:08:10 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:08:10 INFO  time: compiled scala_f4dd477a3a in 0.25s
Oct 02, 2024 2:08:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:08:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:08:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodType;\nimport java.lang.invoke.StringConcatFactory;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.access.JavaLangAccess;\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport jdk.internal.util.SystemProps;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * The VM will invoke the initPhase1 method to complete the initialization\n     * of this class separate from \u003cclinit\u003e.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user. In case this stream is wrapped\n     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n     * should be used for the charset, or consider using\n     * {@link Console#reader()}.\n     *\n     * @see Console#charset()\n     * @see Console#reader()\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user. The encoding used\n     * in the conversion from characters to bytes is equivalent to\n     * {@link Console#charset()} if the {@code Console} exists,\n     * {@link Charset#defaultCharset()} otherwise.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     * The encoding used in the conversion from characters to bytes is\n     * equivalent to {@link Console#charset()} if the {@code Console}\n     * exists, {@link Charset#defaultCharset()} otherwise.\n     *\n     * @see     Console#charset()\n     * @see     Charset#defaultCharset()\n     */\n    public static final PrintStream err \u003d null;\n\n    // indicates if a security manager is possible\n    private static final int NEVER \u003d 1;\n    private static final int MAYBE \u003d 2;\n    private static @Stable int allowSecurityManager;\n\n    // current security manager\n    @SuppressWarnings(\"removal\")\n    private static volatile SecurityManager security;   // read by VM\n\n    // return true if a security manager is allowed\n    private static boolean allowSecurityManager() {\n        return (allowSecurityManager !\u003d NEVER);\n    }\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    private static class CallersHolder {\n        // Remember callers of setSecurityManager() here so that warning\n        // is only printed once for each different caller\n        final static Map\u003cClass\u003c?\u003e, Boolean\u003e callers\n            \u003d Collections.synchronizedMap(new WeakHashMap\u003c\u003e());\n    }\n\n    // Remember initial System.err. setSecurityManager() warning goes here\n    private static volatile @Stable PrintStream initialErrStream;\n\n    private static URL codeSource(Class\u003c?\u003e clazz) {\n        PrivilegedAction\u003cProtectionDomain\u003e pa \u003d clazz::getProtectionDomain;\n        @SuppressWarnings(\"removal\")\n        CodeSource cs \u003d AccessController.doPrivileged(pa).getCodeSource();\n        return (cs !\u003d null) ? cs.getLocation() : null;\n    }\n\n    /**\n     * Sets the system-wide security manager.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @implNote In the JDK implementation, if the Java virtual machine is\n     * started with the system property {@code java.security.manager} set to\n     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n     * method cannot be used to set a security manager.\n     *\n     * @param  sm the security manager or {@code null}\n     * @throws SecurityException\n     *         if the security manager has already been set and its {@code\n     *         checkPermission} method doesn\u0027t allow it to be replaced\n     * @throws UnsupportedOperationException\n     *         if {@code sm} is non-null and a security manager is not allowed\n     *         to be set dynamically\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    @CallerSensitive\n    public static void setSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (allowSecurityManager()) {\n            var callerClass \u003d Reflection.getCallerClass();\n            if (CallersHolder.callers.putIfAbsent(callerClass, true) \u003d\u003d null) {\n                URL url \u003d codeSource(callerClass);\n                final String source;\n                if (url \u003d\u003d null) {\n                    source \u003d callerClass.getName();\n                } else {\n                    source \u003d callerClass.getName() + \" (\" + url + \")\";\n                }\n                initialErrStream.printf(\"\"\"\n                        WARNING: A terminally deprecated method in java.lang.System has been called\n                        WARNING: System::setSecurityManager has been called by %s\n                        WARNING: Please consider reporting this to the maintainers of %s\n                        WARNING: System::setSecurityManager will be removed in a future release\n                        \"\"\", source, callerClass.getName());\n            }\n            implSetSecurityManager(sm);\n        } else {\n            // security manager not allowed\n            if (sm !\u003d null) {\n                throw new UnsupportedOperationException(\n                    \"The Security Manager is deprecated and will be removed in a future release\");\n            }\n        }\n    }\n\n    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (sm !\u003d null) {\n            try {\n                // pre-populates the SecurityManager.packageAccess cache\n                // to avoid recursive permission checking issues with custom\n                // SecurityManager implementations\n                sm.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(sm);\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Force policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system-wide security manager.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static SecurityManager getSecurityManager() {\n        if (allowSecurityManager()) {\n            return security;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @IntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @IntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @IntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties.\n     *\n     * See {@linkplain #getProperties getProperties} for details.\n     */\n    private static Properties props;\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties includes a value\n     * for each of the following keys unless the description of the associated\n     * value indicates that the value is optional.\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version \u003cem\u003e(optional)\u003c/em\u003e \u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty native.encoding}\u003c/th\u003e\n     *     \u003ctd\u003eCharacter encoding name derived from the host environment and/or\n     *     the user\u0027s settings. Setting this system property has no effect.\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@systemProperty jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        if (props \u003d\u003d null) {\n            Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n            VersionProps.init(tempProps);\n            props \u003d createProperties(tempProps);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.isEmpty()) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n         *\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            @SuppressWarnings(\"removal\")\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        @SuppressWarnings(\"removal\")\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @SuppressWarnings(\"removal\")\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector in the Java Virtual Machine.\n     * \u003cp\u003e\n     * Calling the {@code gc} method suggests that the Java Virtual Machine\n     * expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for reuse\n     * by the Java Virtual Machine.\n     * When control returns from the method call, the Java Virtual Machine\n     * has made a best effort to reclaim space from all unused objects.\n     * There is no guarantee that this effort will recycle any particular\n     * number of unused objects, reclaim any particular amount of space, or\n     * complete at any particular time, if at all, before the method returns or ever.\n     * There is also no guarantee that this effort will determine\n     * the change of reachability in any particular number of objects,\n     * or that any particular number of {@link java.lang.ref.Reference Reference}\n     * objects will be cleared and enqueued.\n     *\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an\n     * implementation-dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Create the Properties object from a map - masking out system properties\n     * that are not intended for public access.\n     */\n    private static Properties createProperties(Map\u003cString, String\u003e initialProps) {\n        Properties properties \u003d new Properties(initialProps.size());\n        for (var entry : initialProps.entrySet()) {\n            String prop \u003d entry.getKey();\n            switch (prop) {\n                // Do not add private system properties to the Properties\n                case \"sun.nio.MaxDirectMemorySize\":\n                case \"sun.nio.PageAlignDirectMemory\":\n                    // used by java.lang.Integer.IntegerCache\n                case \"java.lang.Integer.IntegerCache.high\":\n                    // used by sun.launcher.LauncherHelper\n                case \"sun.java.launcher.diag\":\n                    // used by jdk.internal.loader.ClassLoaders\n                case \"jdk.boot.class.path.append\":\n                    break;\n                default:\n                    properties.put(prop, entry.getValue());\n            }\n        }\n        return properties;\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // register the shared secrets - do this first, since SystemProps.initProperties\n        // might initialize CharsetDecoders that rely on it\n        setJavaLangAccess();\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization.\n        // The charset is initialized in System.c and does not depend on the Properties.\n        Map\u003cString, String\u003e tempProps \u003d SystemProps.initProperties();\n        VersionProps.init(tempProps);\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // masked from the system properties.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.\n        VM.saveProperties(tempProps);\n        props \u003d createProperties(tempProps);\n\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        // sun.stdout/err.encoding are set when the VM is associated with the terminal,\n        // thus they are equivalent to Console.charset(), otherwise the encoding\n        // defaults to Charset.defaultCharset()\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. eagerly initialize bootstrap method factories that might interact\n     *    negatively with custom security managers and custom class loaders\n     * 2. set security manager\n     * 3. set system class loader\n     * 4. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be a custom class from\n     * the application classpath or modulepath.\n     */\n    @SuppressWarnings(\"removal\")\n    private static void initPhase3() {\n\n        // Initialize the StringConcatFactory eagerly to avoid potential\n        // bootstrap circularity issues that could be caused by a custom\n        // SecurityManager\n        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n\n        String smProp \u003d System.getProperty(\"java.security.manager\");\n        boolean needWarning \u003d false;\n        if (smProp !\u003d null) {\n            switch (smProp) {\n                case \"disallow\":\n                    allowSecurityManager \u003d NEVER;\n                    break;\n                case \"allow\":\n                    allowSecurityManager \u003d MAYBE;\n                    break;\n                case \"\":\n                case \"default\":\n                    implSetSecurityManager(new SecurityManager());\n                    allowSecurityManager \u003d MAYBE;\n                    needWarning \u003d true;\n                    break;\n                default:\n                    try {\n                        ClassLoader cl \u003d ClassLoader.getBuiltinAppClassLoader();\n                        Class\u003c?\u003e c \u003d Class.forName(smProp, false, cl);\n                        Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                        // Must be a public subclass of SecurityManager with\n                        // a public no-arg constructor\n                        if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                            throw new Error(\"Could not create SecurityManager: \"\n                                             + ctor.toString());\n                        }\n                        // custom security manager may be in non-exported package\n                        ctor.setAccessible(true);\n                        SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                        implSetSecurityManager(sm);\n                        needWarning \u003d true;\n                    } catch (Exception e) {\n                        throw new InternalError(\"Could not create SecurityManager\", e);\n                    }\n                    allowSecurityManager \u003d MAYBE;\n            }\n        } else {\n            allowSecurityManager \u003d MAYBE;\n        }\n\n        if (needWarning) {\n            System.err.println(\"\"\"\n                    WARNING: A command line option has enabled the Security Manager\n                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n        }\n\n        initialErrStream \u003d System.err;\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, Class\u003c?\u003e lookup, String name, byte[] b, ProtectionDomain pd,\n                                        boolean initialize, int flags, Object classData) {\n                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n                return ClassLoader.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            @SuppressWarnings(\"removal\")\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            @SuppressWarnings(\"removal\")\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn) {\n                m.implAddExports(pn);\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Set\u003cString\u003e concealedPackages, Set\u003cString\u003e exportedPackages) {\n                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public Module addEnableNativeAccess(Module m) {\n                return m.implAddEnableNativeAccess();\n            }\n            public void addEnableNativeAccessAllUnnamed() {\n                Module.implAddEnableNativeAccessAllUnnamed();\n            }\n            public boolean isEnableNativeAccess(Module m) {\n                return m.implIsEnableNativeAccess();\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n                layer.bindToLoader(loader);\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return String.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return String.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return String.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return String.getBytesUTF8NoRepl(s);\n            }\n\n            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                StringLatin1.inflate(src, srcOff, dst, dstOff, len);\n            }\n\n            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n                return String.decodeASCII(src, srcOff, dst, dstOff, len);\n            }\n\n            public void setCause(Throwable t, Throwable cause) {\n                t.setCause(cause);\n            }\n\n            public ProtectionDomain protectionDomain(Class\u003c?\u003e c) {\n                return c.protectionDomain();\n            }\n\n            public MethodHandle stringConcatHelper(String name, MethodType methodType) {\n                return StringConcatHelper.lookupStatic(name, methodType);\n            }\n\n            public long stringConcatInitialCoder() {\n                return StringConcatHelper.initialCoder();\n            }\n\n            public long stringConcatMix(long lengthCoder, String constant) {\n                return StringConcatHelper.mix(lengthCoder, constant);\n            }\n\n            public String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n                return String.join(prefix, suffix, delimiter, elements, size);\n            }\n\n            public Object classData(Class\u003c?\u003e c) {\n                return c.getClassData();\n            }\n\n            @Override\n            public long findNative(ClassLoader loader, String entry) {\n                return ClassLoader.findNative(loader, entry);\n            }\n\n            @Override\n            public void exit(int statusCode) {\n                Shutdown.exit(statusCode);\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Oct 02, 2024 2:08:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 191: jar:file:///C:/Users/Vishwasujit/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.02 14:44:03 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:44:03 INFO  time: compiled scala_f4dd477a3a in 0.29s
2024.10.02 14:44:10 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:44:10 INFO  time: compiled scala_f4dd477a3a in 0.21s
2024.10.02 14:56:04 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:56:04 INFO  time: compiled scala_f4dd477a3a in 0.39s
2024.10.02 14:56:41 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:56:41 INFO  time: compiled scala_f4dd477a3a in 0.25s
2024.10.02 14:57:32 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:57:32 INFO  time: compiled scala_f4dd477a3a in 84ms
2024.10.02 14:57:56 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:57:56 INFO  time: compiled scala_f4dd477a3a in 87ms
Oct 02, 2024 2:58:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2177
2024.10.02 14:58:27 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:58:27 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.02 14:58:45 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:58:45 INFO  time: compiled scala_f4dd477a3a in 0.15s
2024.10.02 14:58:54 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 14:58:54 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 15:03:12 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:03:12 INFO  time: compiled scala_f4dd477a3a in 0.27s
2024.10.02 15:03:29 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:03:29 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 15:03:37 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:03:37 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.02 15:03:53 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:03:53 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.02 15:04:01 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:04:01 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.02 15:04:13 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:04:13 INFO  time: compiled scala_f4dd477a3a in 0.26s
2024.10.02 15:04:19 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.02 15:04:19 INFO  time: compiled scala_f4dd477a3a in 0.39s
2024.10.03 10:00:11 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:00:11 INFO  time: compiled scala_f4dd477a3a in 0.46s
Oct 03, 2024 10:01:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3168
2024.10.03 10:01:45 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:01:45 INFO  time: compiled scala_f4dd477a3a in 0.26s
2024.10.03 10:03:18 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:03:18 INFO  time: compiled scala_f4dd477a3a in 0.28s
2024.10.03 10:04:56 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:04:56 INFO  time: compiled scala_f4dd477a3a in 0.14s
2024.10.03 10:05:20 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:05:20 INFO  time: compiled scala_f4dd477a3a in 0.22s
2024.10.03 10:05:57 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:05:57 INFO  time: compiled scala_f4dd477a3a in 95ms
2024.10.03 10:06:12 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:06:12 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.03 10:07:02 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:07:02 INFO  time: compiled scala_f4dd477a3a in 99ms
2024.10.03 10:07:34 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:07:34 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.03 10:07:58 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:07:58 INFO  time: compiled scala_f4dd477a3a in 0.2s
2024.10.03 10:08:07 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:08:07 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.03 10:08:53 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:08:53 INFO  time: compiled scala_f4dd477a3a in 0.25s
2024.10.03 10:09:17 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:09:17 INFO  time: compiled scala_f4dd477a3a in 0.19s
2024.10.03 10:18:54 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:18:54 INFO  time: compiled scala_f4dd477a3a in 0.15s
2024.10.03 10:19:14 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:19:14 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.03 10:19:44 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:19:44 INFO  time: compiled scala_f4dd477a3a in 83ms
2024.10.03 10:20:11 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:20:11 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.03 10:20:52 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:20:52 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.03 10:21:04 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:21:04 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.03 10:21:31 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:21:31 INFO  time: compiled scala_f4dd477a3a in 0.14s
2024.10.03 10:22:20 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:22:20 INFO  time: compiled scala_f4dd477a3a in 0.19s
2024.10.03 10:22:28 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:22:28 INFO  time: compiled scala_f4dd477a3a in 0.17s
Oct 03, 2024 10:23:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4818
2024.10.03 10:23:38 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:23:38 INFO  time: compiled scala_f4dd477a3a in 0.17s
2024.10.03 10:34:31 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 10:34:31 INFO  time: compiled scala_f4dd477a3a in 0.18s
2024.10.03 17:12:35 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Device.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:12:35 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Device.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:12:35 WARN  no build target for: D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Device.scala
2024.10.03 17:12:36 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Device.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:12:36 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Device.scala
2024.10.03 17:12:36 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:12:36 INFO  time: compiled scala_f4dd477a3a in 0.3s
2024.10.03 17:12:36 INFO  time: Imported build in 0.67s
2024.10.03 17:12:36 INFO  running doctor check
2024.10.03 17:12:36 INFO  java targets: scala_f4dd477a3a-test, scala_f4dd477a3a
2024.10.03 17:12:38 INFO  time: indexed workspace in 1.28s
2024.10.03 17:12:38 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Device.scala
2024.10.03 17:15:39 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:15:39 INFO  time: compiled scala_f4dd477a3a in 0.26s
Oct 03, 2024 5:15:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5161
Oct 03, 2024 5:15:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5168
2024.10.03 17:15:51 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Device.scala
2024.10.03 17:15:53 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:15:53 INFO  time: compiled scala_f4dd477a3a in 0.1s
2024.10.03 17:15:57 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Device.scala
2024.10.03 17:16:03 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Device.scala
2024.10.03 17:16:04 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:16:04 INFO  time: compiled scala_f4dd477a3a in 0.11s
2024.10.03 17:16:07 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:16:07 INFO  time: compiled scala_f4dd477a3a in 0.26s
2024.10.03 17:16:16 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:16:16 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:16:17 INFO  Cancelling compilation on scala-cli server
2024.10.03 17:16:17 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:16:17 INFO  time: compiled scala_f4dd477a3a in 0.31s
2024.10.03 17:16:17 INFO  time: Imported build in 0.39s
2024.10.03 17:16:17 INFO  running doctor check
2024.10.03 17:16:17 INFO  java targets: scala_f4dd477a3a-test, scala_f4dd477a3a
2024.10.03 17:16:17 INFO  time: indexed workspace in 0.84s
2024.10.03 17:17:03 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:17:03 INFO  time: compiled scala_f4dd477a3a in 0.21s
2024.10.03 17:18:20 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Energymeter.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:18:20 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Energymeter.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:18:20 WARN  no build target for: D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Energymeter.scala
2024.10.03 17:18:20 INFO  no build target found for D:\Practise\hello-world\src\main\scala\Energy Meter\EM_Energymeter.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.03 17:18:20 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Energymeter.scala
2024.10.03 17:18:20 INFO  running doctor check
2024.10.03 17:18:20 INFO  java targets: scala_f4dd477a3a-test, scala_f4dd477a3a
2024.10.03 17:18:20 INFO  compiling scala_f4dd477a3a (1 scala source)
2024.10.03 17:18:20 INFO  time: compiled scala_f4dd477a3a in 86ms
2024.10.03 17:18:21 INFO  time: indexed workspace in 0.83s
2024.10.03 17:18:39 WARN  Could not find semantic tokens for: file:///D:/Practise/hello-world/src/main/scala/Energy%20Meter/EM_Energymeter.scala
2024.10.03 17:19:09 INFO  Shutting down server
2024.10.03 17:19:09 INFO  shutting down Metals
2024.10.03 17:19:09 INFO  Shut down connection with build server.
2024.10.03 17:19:09 INFO  Exiting server
